// Copyright (c) 2021 Thomas Otterson
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

use crate::double::{tables, Double};
use std::f64;

impl Double {
    /// Computes the exponential function, *e*<sup>x</sup>, where *x* is this `Double`.
    ///
    /// The result of this function grows rapidly. Once *x* exceeds 708, the result is too
    /// large to represent with a `Double`; at that point the function begins to return
    /// [`INFINITY`]. The limit on the low end is less due to the fact that the second
    /// component needs to fit in an `f64` rather than the first, along with extra bits used
    /// in argument reduction; this function begins to return 0 at -600.
    ///
    /// As the `Double` grows this function loses precision, albeit slowly. Accuracy never
    /// falls below 28 digits, even at max and min values of `x`. The following table shows
    /// the ranges where numbers of accurate digits can be expected.
    ///
    /// | Accuracy (digits) | Smallest *x* | Largest *x* |
    /// |:-----------------:|:------------:|:-----------:|
    /// | 30                | -9           | 10          |
    /// | 29                | -140         | 150         |
    /// | 28                | -600         | 708         |
    /// 
    /// The algorithm uses a polynomial approximation, which is a method that has good
    /// performance.
    ///
    /// # Examples
    /// ```
    /// # #[macro_use] extern crate qd;
    /// # use qd::Double;
    /// # fn main() {
    /// let x = dd!(2).exp();
    /// let expected = dd!("7.3890560989306502272304274605750057");
    ///
    /// let diff = (x - expected).abs();
    /// assert!(diff < dd!(1e-29));
    /// # }
    /// ```
    ///
    /// [`INFINITY`]: #associatedconstant.INFINITY
    #[allow(clippy::many_single_char_names)]
    pub fn exp(self) -> Double {
        match self.pre_exp() {
            Some(r) => r,
            None => {
                // Strategy:
                //
                // We use a 16th degree polynomial approximation of `exp` generated by the
                // Remez algorithm. This polynomial has a maximum error of ~2.1592756e-35 on
                // the interval [0, 0.25]. The coefficients are stored as quad-doubles in
                // table.rs.
                //
                // This polynomial is only accurate within that small interval, but we can
                // take advantage of two identities to help us. First, if the number is
                // negative, we have
                //
                //     exp(x) = 1 / exp(-x)
                //
                // which will let us change the sign of a negative number to positive at the
                // cost of having to take the reciprocal at the end. Secondly, we have
                //
                //     exp(2x) = exp(x)^2
                //
                // We can make this work by halving x however many times we need to get it
                // into our target range. After we have our answer, we must square that the
                // same number of times to compensate.

                // Start with the absolute value of the original number, which prevents the
                // evaluated number from being on the negative side of [0, 0.25]. If the
                // number is negative, we will compensate at the end by taking the positive
                // answer's reciprocal.
                let mut x = self.abs();

                // Calculate k. m is the number of times that we have to divide by 2 to get
                // into the target range. k is then 2^m, which is actually used in later
                // calculations to avoid using loops to divide/square m times. If x is
                // already in the range we want, we don't have to do anything, and we declare
                // k to be 1.
                let k = if x[0] <= 0.25 {
                    1.0
                } else {
                    // Rounding x.log2() up will give the number of times to divide to get
                    // below 1, so we add two more times to get below 0.25
                    let m = x[0].log2().ceil() as i32 + 2;
                    2f64.powi(m)
                };
                // Divide by 2, m times. This is the same as dividing by 2^m, which is what
                // we defined k to be. We do **not** use `mul_pwr2` here even though it's
                // much faster than division because it loses accuracy with even moderately
                // large numbers. Division happens only once so this shouldn't be too bad.
                // After this division, x will be between 0.0 and 0.25 inclusive.
                x /= Double::from(k);

                // Evaluate the polynomial. We have to then raise it to the 2^m power (again,
                // k = 2^m), which will return the answer to its original range.
                let r = eval_polynomial(&tables::COEFFS_EXP, &x).powi(k as i32);

                // If the original number was negative, we've done the calculation with the
                // wrong sign. Taking the reciprocal corrects this.
                if self.is_sign_negative() {
                    r.recip()
                } else {
                    r
                }
            }
        }
    }

    /// Calculates the natural logarithm, log<sub>*e*</sub>, of the `Double`.
    ///
    /// # Examples
    /// ```
    /// # #[macro_use] extern crate qd;
    /// # use qd::Double;
    /// # fn main() {
    /// let x = dd!(7).ln();
    /// let expected = dd!("1.9459101490553133051053527434432");
    ///
    /// let diff = (x - expected).abs();
    /// assert!(diff < dd!(1e-29));
    /// # }
    /// ```
    pub fn ln(self) -> Double {
        match self.pre_ln() {
            Some(r) => r,
            None => {
                // Strategy:
                //
                // The Taylor series for logarithms converges much more slowly than that of
                // exp because of the lack of a factorial term in the denominator. Hence
                // this routine instead tries to determine the root of the function
                //
                //      f(x) = exp(x) - a
                //
                // using Newton's iteration. This iteration is given by
                //
                //      x' = x - f(x)/f'(x)              (general Newton's iteration)
                //         = x - (exp(x) - a) / exp(x)
                //         = x - (1 - a / exp(x))
                //         = x - (1 - a * exp(-x))
                //         = x + a * exp(-x) - 1
                //
                // Because the derivative of exp(x) is exp(x), this is perhaps the simplest
                // of all Newton iterations.
                let mut x = Double(self.0.ln(), 0.0); // initial approximation

                let k = x.0.abs().log2().floor() as i32;
                let eps = Double::EPSILON.mul_pwr2(2f64.powi(k + 2));

                loop {
                    let r = x + self * (-x).exp() - Double::ONE;
                    if (x - r).abs() < eps {
                        return r;
                    }
                    x = r;
                }
            }
        }
    }

    /// Calculates log<sub>10</sub> of the `Double`.
    ///
    /// # Examples
    /// ```
    /// # #[macro_use] extern crate qd;
    /// # use qd::Double;
    /// # fn main() {
    /// let x = Double::E.log10();
    /// let expected = dd!("0.434294481903251827651128918916605");
    ///
    /// let diff = (x - expected).abs();
    /// assert!(diff < dd!(1e-30));
    /// # }
    /// ```
    #[inline]
    pub fn log10(self) -> Double {
        self.ln() / Double::LN_10
    }

    /// Calculates log<sub>2</sub> of the `Double`.
    ///
    /// # Examples
    /// ```
    /// # #[macro_use] extern crate qd;
    /// # use qd::Double;
    /// # fn main() {
    /// let x = dd!(10).log2();
    /// let expected = dd!("3.32192809488736234787031942948939");
    ///
    /// let diff = (x - expected).abs();
    /// assert!(diff < dd!(1e-29));
    /// # }
    /// ```
    #[inline]
    pub fn log2(self) -> Double {
        self.ln() / Double::LN_2
    }

    /// Calculates the base `b` logarithm (log<sub>`b`</sub>) of the `Double`.
    ///
    /// If the goal is to calculate the base *e*, base 2, or base 10 logarithms of `self`,
    /// the specialized functions for those purposes([`ln`], [`log2`], and [`log10`]
    /// respectively) will be more efficient.
    ///
    /// # Examples
    /// ```
    /// # #[macro_use] extern crate qd;
    /// # use qd::Double;
    /// # fn main() {
    /// let x = dd!(10).log(7.0);
    /// let expected = dd!("1.18329466245493832681792856164686");
    ///
    /// let diff = (x - expected).abs();
    /// assert!(diff < dd!(1e-29));
    /// # }
    /// ```
    ///
    /// [`ln`]: #method.ln
    /// [`log2`]: #method.log2
    /// [`log10`]: #method.log10
    #[inline]
    pub fn log(self, b: f64) -> Double {
        self.ln() / Double::from(b).ln()
    }

    // Precalc functions
    //
    // This series of functions returns `Some` with a value that is to be returned, if it
    // turns out that the function doesn't have to be calculated because a shortcut result
    // is known. They return `None` if the value has to be calculated normally.
    //
    // This keeps the public functions from being mucked up with code that does validation
    // rather than calculation.

    #[inline]
    fn pre_exp(&self) -> Option<Double> {
        if self.0 < -600.0 {
            Some(Double::ZERO)
        } else if self.0 > 708.0 {
            Some(Double::INFINITY)
        } else if self.is_nan() {
            Some(Double::NAN)
        } else if self.is_zero() {
            Some(Double::ONE)
        } else if *self == Double::ONE {
            Some(Double::E)
        } else {
            None
        }
    }

    #[inline]
    fn pre_ln(&self) -> Option<Double> {
        if self.is_nan() {
            Some(Double::NAN)
        } else if self.is_sign_negative() {
            Some(Double::NAN)
        } else if self.is_zero() {
            Some(Double::NEG_INFINITY)
        } else if self.is_infinite() {
            Some(Double::INFINITY)
        } else if *self == Double::ONE {
            Some(Double::ZERO)
        } else {
            None
        }
    }
}

#[inline]
fn eval_polynomial(cs: &[Double], x: &Double) -> Double {
    match cs.split_last() {
        Some((last, rest)) => rest
            .iter()
            .rev()
            .fold(last.clone(), |acc, num| x * acc + num),
        None => Double::ZERO,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exp() {
        assert_all_close!(
            dd!("1.0644944589178594295633905946428894"), dd!(0.0625).exp();
            dd!("1.1331484530668263168290072278117932"), dd!(0.125).exp();
            dd!("1.2062302494209807106555860104464342"), dd!(0.1875).exp();
            dd!("1.2840254166877414840734205680624368"), dd!(0.25).exp();

            dd!("0.93941306281347578611971082462230501"), dd!(-0.0625).exp();
            dd!("0.88249690258459540286489214322905049"), dd!(-0.125).exp();
            dd!("0.82902911818040034301464550934308218"), dd!(-0.1875).exp();
            dd!("0.77880078307140486824517026697832046"), dd!(-0.25).exp();

            dd!("23.140692632779269005729086367948552"), Double::PI.exp();
            dd!("15.154262241479264189760430272629902"), Double::E.exp();
            dd!("0.043213918263772249774417737171728016"), (-Double::PI).exp();
            dd!("0.065988035845312537076790187596846535"), (-Double::E).exp();
            dd!("535.49165552476473650304932958904745"), Double::MUL_2_PI.exp();
            dd!("4.8104773809653516554730356667038329"), Double::FRAC_PI_2.exp();
            dd!("4.113250378782927517173581815140309"), Double::SQRT_2.exp();
            dd!("2.0281149816474724511081261127463503"), Double::FRAC_1_SQRT_2.exp();

            Double::E, Double::E.ln().exp();
            Double::ONE, Double::ONE.ln().exp();
            Double::E, Double::ONE.exp();
            dd!("2.7182818284590452353630057531811221"), dd!("1.000000000000000000001").exp();
            dd!("2.7182818284590452353575691895242041"), dd!("0.999999999999999999999").exp();
            dd!("22026.465794806716516957900645284255"), dd!(10).exp();
            dd!("0.00012340980408667954949763669073003385"), dd!(-9).exp();
        );
        assert_precision_all!(
            dd!("1.3937095806663796973183419371414568e+65"), dd!(150).exp(), 29;
            dd!("1.5804200602736129648293184125529729e-61"), dd!(-140).exp(), 29;
            dd!("2.6503965530043108163386794472695841e-261"), dd!(-600).exp(), 28;
            dd!("1.0142320547350045094553295952312673e+304"), dd!(700).exp(), 28;
            dd!("3.0233831442760550147756219850967309e+307"), dd!(708).exp(), 28;
        );
        assert_all_exact!(
            Double::ZERO, dd!(-710).exp();
            Double::INFINITY, dd!(710).exp();
            Double::ONE, Double::ZERO.exp();
            Double::ONE, Double::NEG_ZERO.exp();
            Double::INFINITY, Double::INFINITY.exp();
            Double::ZERO, Double::NEG_INFINITY.exp();
            Double::NAN, Double::NAN.exp();
        );
    }

    #[test]
    fn ln() {
        assert_all_close!(
            dd!("1.1447298858494001741434273513531"), Double::PI.ln();
            Double::ONE, Double::E.ln();
            dd!("1.8378770664093454835606594728112"), Double::MUL_2_PI.ln();
            dd!("0.45158270528945486472619522989488"), Double::FRAC_PI_2.ln();
            dd!("0.34657359027997265470861606072909"), Double::SQRT_2.ln();
            dd!("-0.34657359027997265470861606072909"), Double::FRAC_1_SQRT_2.ln();
            dd!("46.051701859880913680359829093687287"), dd!("1e20").ln();
            dd!("69.077552789821370520539743640530926"), dd!("1e30").ln();
            dd!("-667.74967696827324836521752185847"), dd!("1e-290").ln();
        );
        assert_all_exact!(
            Double::NAN, (-Double::PI).ln();
            Double::NAN, (-Double::E).ln();
            Double::ZERO, Double::ONE.ln();
            Double::NEG_INFINITY, Double::ZERO.ln();
            Double::NAN, Double::NEG_ZERO.ln();
            Double::INFINITY, Double::INFINITY.ln();
            Double::NAN, Double::NEG_INFINITY.ln();
            Double::NAN, Double::NAN.ln();
        );
    }

    #[test]
    fn log10() {
        assert_close!(dd!("1.62324929039790046322098305657224"), dd!(42).log10());
        assert_close!(dd!("2.38560627359831218647513951627558"), dd!(243).log10());
        assert_exact!(Double::ZERO, dd!(1).log10());
        assert_close!(Double::ONE, dd!(10).log10());
    }

    #[test]
    fn log10_zero() {
        assert_exact!(Double::NAN, Double::ZERO.log10());
        assert_exact!(Double::NAN, Double::NEG_ZERO.log10());
    }

    #[test]
    fn log10_inf() {
        assert_exact!(Double::INFINITY, Double::INFINITY.log10());
        assert_exact!(Double::NAN, Double::NEG_INFINITY.log10());
    }

    #[test]
    fn log10_nan() {
        assert_exact!(Double::NAN, Double::NAN.log10());
    }

    #[test]
    fn log10_neg() {
        assert_exact!(Double::NAN, dd!(-1).log10());
    }

    #[test]
    fn log2() {
        assert_close!(dd!("3.32192809488736234787031942948939"), dd!(10).log2());
        assert_close!(dd!("7.92481250360578090726869471973908"), dd!(243).log2());
        assert_exact!(Double::ZERO, dd!(1).log2());
        assert_close!(Double::ONE, dd!(2).log2());
    }

    #[test]
    fn log2_zero() {
        assert_exact!(Double::NAN, Double::ZERO.log2());
        assert_exact!(Double::NAN, Double::NEG_ZERO.log2());
    }

    #[test]
    fn log2_inf() {
        assert_exact!(Double::INFINITY, Double::INFINITY.log2());
        assert_exact!(Double::NAN, Double::NEG_INFINITY.log2());
    }

    #[test]
    fn log2_nan() {
        assert_exact!(Double::NAN, Double::NAN.log2());
    }

    #[test]
    fn log2_neg() {
        assert_exact!(Double::NAN, dd!(-1).log2());
    }

    #[test]
    fn log() {
        assert_close!(dd!("1.17473150366718002267187494833236"), dd!(10).log(7.1));
        assert_close!(
            dd!("4.22480900593537861528922880434435"),
            dd!(243).log(3.67)
        );
        assert_exact!(Double::ZERO, dd!(1).log(6.3));
        assert_close!(Double::ONE, dd!(3.3).log(3.3));
    }

    #[test]
    fn log_zero() {
        assert_exact!(Double::NAN, Double::ZERO.log(9.2));
        assert_exact!(Double::NAN, Double::NEG_ZERO.log(1.8));
    }

    #[test]
    fn log_inf() {
        assert_exact!(Double::INFINITY, Double::INFINITY.log(7.3));
        assert_exact!(Double::NAN, Double::NEG_INFINITY.log(7.3));
    }

    #[test]
    fn log_nan() {
        assert_exact!(Double::NAN, Double::NAN.log(3.4));
    }

    #[test]
    fn log_neg() {
        assert_exact!(Double::NAN, dd!(-1).log(1.8));
    }
}
