var N = null;var searchIndex = {};
searchIndex["qd"]={"doc":"Rust implementation of double-double and quad-double high-precision floating point numbers.","items":[[3,"Double","qd","A 128-bit floating-point number implemented as the unevaluated sum of two 64-bit floating-point numbers.",N,N],[18,"RADIX","","The radix or base of the internal representation of `Double`. This is the same as the representation in the underlying f64.",0,N],[18,"MANTISSA_DIGITS","","Number of significant digits in base 2.",0,N],[18,"DIGITS","","Approximate number of significant digits in base 10.",0,N],[18,"EPSILON","","[Machine epsilon] value for `Double`.",0,N],[18,"MIN","","Smallest finite `Double` value.",0,N],[18,"MIN_POSITIVE","","Smallest positive normal `Double` value.",0,N],[18,"MAX","","Largest finite `Double` value.",0,N],[18,"MIN_EXP","","One greater than the minimum possible normal power of 2 exponent.",0,N],[18,"MAX_EXP","","Maximum possible power of 2 exponent.",0,N],[18,"MIN_10_EXP","","Minimum possible normal power of 10 exponent.",0,N],[18,"MAX_10_EXP","","Maximum possible power of 10 exponent.",0,N],[18,"NAN","","Not a Number (NaN).",0,N],[18,"INFINITY","","Infinity (∞).",0,N],[18,"NEG_INFINITY","","Negative infinity (-∞).",0,N],[18,"ZERO","","Zero (0)",0,N],[18,"NEG_ZERO","","Negative zero (-0)",0,N],[18,"ONE","","One (1)",0,N],[18,"PI","","Archimedes' constant (π)",0,N],[18,"MUL_2_PI","","2π",0,N],[18,"FRAC_PI_2","","π/2",0,N],[18,"FRAC_PI_3","","π/3",0,N],[18,"FRAC_PI_4","","π/4",0,N],[18,"FRAC_PI_6","","π/6",0,N],[18,"FRAC_PI_8","","π/8",0,N],[18,"FRAC_PI_16","","π/16",0,N],[18,"FRAC_3_PI_4","","3π/4",0,N],[18,"FRAC_1_PI","","1/π",0,N],[18,"FRAC_2_PI","","2/π",0,N],[18,"FRAC_2_SQRT_PI","","2/√π",0,N],[18,"SQRT_2","","√2",0,N],[18,"FRAC_1_SQRT_2","","1/√2",0,N],[18,"E","","Euler's number (e)",0,N],[18,"LOG2_10","","log₂ 10",0,N],[18,"LOG2_E","","log₂ e",0,N],[18,"LOG10_2","","log 2",0,N],[18,"LOG10_E","","log e",0,N],[18,"LN_2","","ln 2",0,N],[18,"LN_10","","ln 10",0,N],[11,"from_add","","Creates a new double-double representing the sum of two floats.",0,[[["f64"],["f64"]],["double"]]],[11,"from_sub","","Creates a new double-double representing the difference of two floats.",0,[[["f64"],["f64"]],["double"]]],[11,"from_mul","","Creates a new double-double representing the product of two floats.",0,[[["f64"],["f64"]],["double"]]],[11,"from_div","","Creates a new double-double representing the quotient of two floats.",0,[[["f64"],["f64"]],["double"]]],[11,"recip","","Calculates the reciprocal of the number.",0,[[["self"]],["double"]]],[11,"as_float","","Converts the number into an `f64`.",0,[[["self"]],["f64"]]],[11,"as_int","","Converts the number into an `i64`.",0,[[["self"]],["i64"]]],[11,"sqr","","Calculates the square of the number.",0,[[["self"]],["double"]]],[11,"powi","","Calculates the number raised to an integral power.",0,[[["self"],["i32"]],["double"]]],[11,"powf","","Calculates the number raised to a double-double power.",0,[[["self"],["double"]],["double"]]],[11,"ldexp","","Calculates `self` × 2`n` and returns it as a new `Double`.",0,[[["self"],["i32"]],["double"]]],[11,"sqrt","","Calculates the square root of the number.",0,[[["self"]],["double"]]],[11,"cbrt","","Calculates the cube root of the number.",0,[[["self"]],["double"]]],[11,"nroot","","Calculates the `n`th root of the number.",0,[[["self"],["i32"]],["double"]]],[11,"exp","","Computes the exponential function, ex, for the number.",0,[[["self"]],["double"]]],[11,"ln","","Calculates the natural logarithm, loge, of the number.",0,[[["self"]],["double"]]],[11,"log10","","Calculates log10 of the number.",0,[[["self"]],["double"]]],[11,"log2","","Calculates log2 of the number.",0,[[["self"]],["double"]]],[11,"log","","Calculates the base `b` logarithm (log`b`) of the number.",0,[[["self"],["f64"]],["double"]]],[11,"sin","","Computes the sine of the number.",0,[[["self"]],["double"]]],[11,"cos","","Computes the cosine of the number.",0,[[["self"]],["double"]]],[11,"sin_cos","","Simultaneously computes the sine and the cosine of the number. This is more efficient if you need both numbers. Returns `(sin(x), cos(x))`.",0,N],[11,"tan","","Computes the tangent of the number.",0,[[["self"]],["double"]]],[11,"atan2","","Computes the 2-argument arctangent of the number (`y`) and `other` (`x`) in radians.",0,[[["self"],["double"]],["double"]]],[11,"atan","","Computes the arctangent of the number. The return value is in the range [-π/2, π/2].",0,[[["self"]],["double"]]],[11,"asin","","Computes the arcsine of the number. The return value is in the range [-π/2, π/2] for any number in the range [-1, 1]. Otherwise the return value is `NaN`.",0,[[["self"]],["double"]]],[11,"acos","","Computes the arccosine of the number. The return value is in the range [0, π] for any number in the range [-1, 1]. Otherwise the return value is `NaN`.",0,[[["self"]],["double"]]],[11,"sinh","","Computes the hyperbolic sine of the number.",0,[[["self"]],["double"]]],[11,"cosh","","Computes the hyperbolic cosine of the number.",0,[[["self"]],["double"]]],[11,"tanh","","Computes the hyperbolic tangent of the number.",0,[[["self"]],["double"]]],[11,"sinh_cosh","","Simultaneously computes the hyperbolic sine and cosine of the number.",0,N],[11,"asinh","","Calculates the inverse hyperbolic sine of the number.",0,[[["self"]],["double"]]],[11,"acosh","","Calculates the inverse hyperbolic cosine of the number.",0,[[["self"]],["double"]]],[11,"atanh","","Calculates the inverse hyperbolic tangent of the number.",0,[[["self"]],["double"]]],[11,"abs","","Calculates the absolute value of the number.",0,[[["self"]],["double"]]],[11,"floor","","Returns the largest integer less than or equal to the number.",0,[[["self"]],["double"]]],[11,"ceil","","Returns the smallest integer greater than or equal to the number.",0,[[["self"]],["double"]]],[11,"round","","Returns the nearest integer to the number. Half-way cases are rounded away from `0.0`.",0,[[["self"]],["double"]]],[11,"trunc","","Returns the integer part of the number.",0,[[["self"]],["double"]]],[11,"fract","","Returns the fractional part of the number.",0,[[["self"]],["double"]]],[11,"signum","","Returns a number that represents the sign of the number.",0,[[["self"]],["double"]]],[11,"classify","","Returns the floating point category of the number. If only one property is being tested, it's generally faster to use the specific predicate rather than this function.",0,[[["self"]],["fpcategory"]]],[11,"is_normal","","Returns `true` if the number is neither zero, infinite, subnormal, or `NaN`.",0,[[["self"]],["bool"]]],[11,"is_zero","","Returns `true` if the number is either positive or negative zero.",0,[[["self"]],["bool"]]],[11,"is_sign_negative","","Returns `true` if the number is negative, including negative zero and infinity and `NaN` with a negative sign bit.",0,[[["self"]],["bool"]]],[11,"is_sign_positive","","Returns `true` if the number is positive, including positive zero and infinity and `NaN` with a positive sign bit.",0,[[["self"]],["bool"]]],[11,"is_nan","","Returns `true` if this value is `NaN`.",0,[[["self"]],["bool"]]],[11,"is_infinite","","Returns `true` if this number is positive or negative infinity.",0,[[["self"]],["bool"]]],[11,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",0,[[["self"]],["bool"]]],[11,"new","","Creates a `Double` with the two arguments as the internal components.",0,[[["f64"],["f64"]],["double"]]],[11,"norm","","Creates a `Double` by normalizing the sum of two arguments.",0,[[["f64"],["f64"]],["double"]]],[0,"error","","",N,N],[3,"ParseError","qd::error","",N,N],[12,"kind","","",1,N],[4,"ErrorKind","","",N,N],[13,"Empty","","",2,N],[13,"Invalid","","",2,N],[14,"dd","qd","Creates a new double-double from another number or from a string.",N,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","qd::error","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"clone","qd","",0,[[["self"]],["double"]]],[11,"clone","qd::error","",1,[[["self"]],["parseerror"]]],[11,"clone","","",2,[[["self"]],["errorkind"]]],[11,"from","qd","",0,N],[11,"from","","",0,[[["f32"]],["double"]]],[11,"from","","",0,N],[11,"from","","",0,[[["f64"]],["double"]]],[11,"from","","",0,N],[11,"from","","",0,[[["i8"]],["double"]]],[11,"from","","",0,N],[11,"from","","",0,[[["u8"]],["double"]]],[11,"from","","",0,N],[11,"from","","",0,[[["i16"]],["double"]]],[11,"from","","",0,N],[11,"from","","",0,[[["u16"]],["double"]]],[11,"from","","",0,N],[11,"from","","",0,[[["i32"]],["double"]]],[11,"from","","",0,N],[11,"from","","",0,[[["u32"]],["double"]]],[11,"from","","",0,N],[11,"from","","",0,[[["u64"]],["double"]]],[11,"from","","",0,N],[11,"from","","",0,[[["i64"]],["double"]]],[11,"from","","Converts a string representation of a number into a `Double`.",0,[[["str"]],["double"]]],[11,"partial_cmp","","",0,[[["self"],["double"]],["option",["ordering"]]]],[11,"eq","","",0,[[["self"],["double"]],["bool"]]],[11,"eq","qd::error","",1,[[["self"],["parseerror"]],["bool"]]],[11,"ne","","",1,[[["self"],["parseerror"]],["bool"]]],[11,"eq","","",2,[[["self"],["errorkind"]],["bool"]]],[11,"fmt","qd","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","qd::error","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","qd","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","qd::error","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","qd","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"from_str","","",0,[[["str"]],["result",["double","parseerror"]]]],[11,"add","","",0,[[["self"],["double"]],["double"]]],[11,"add","","",0,[[["self"],["double"]],["double"]]],[11,"sub","","",0,[[["self"],["double"]],["double"]]],[11,"sub","","",0,[[["self"],["double"]],["double"]]],[11,"mul","","",0,[[["self"],["double"]],["double"]]],[11,"mul","","",0,[[["self"],["double"]],["double"]]],[11,"div","","",0,[[["self"],["double"]],["double"]]],[11,"div","","",0,[[["self"],["double"]],["double"]]],[11,"rem","","",0,[[["self"],["double"]],["double"]]],[11,"rem","","",0,[[["self"],["double"]],["double"]]],[11,"neg","","",0,[[["self"]],["double"]]],[11,"add_assign","","",0,[[["self"],["double"]]]],[11,"add_assign","","",0,[[["self"],["double"]]]],[11,"sub_assign","","",0,[[["self"],["double"]]]],[11,"sub_assign","","",0,[[["self"],["double"]]]],[11,"mul_assign","","",0,[[["self"],["double"]]]],[11,"mul_assign","","",0,[[["self"],["double"]]]],[11,"div_assign","","",0,[[["self"],["double"]]]],[11,"div_assign","","",0,[[["self"],["double"]]]],[11,"rem_assign","","",0,[[["self"],["double"]]]],[11,"rem_assign","","",0,[[["self"],["double"]]]],[11,"sum","","",0,[[["i"]],["double"]]],[11,"sum","","",0,[[["i"]],["double"]]],[11,"product","","",0,[[["i"]],["double"]]],[11,"product","","",0,[[["i"]],["double"]]]],"paths":[[3,"Double"],[3,"ParseError"],[4,"ErrorKind"]]};
initSearch(searchIndex);
