<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Double` struct in crate `qd`."><meta name="keywords" content="rust, rustlang, rust-lang, Double"><title>qd::Double - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"
      integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y"
      crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js"
        integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js"
        integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe"
        crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "\\(", right: "\\)", display: false },
        { left: "$", right: "$", display: false },
        { left: "\\[", right: "\\]", display: true }
      ]
    });
  });
</script>

<style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../qd/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Struct Double</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.abs">abs</a><a href="#method.acos">acos</a><a href="#method.acosh">acosh</a><a href="#method.agm">agm</a><a href="#method.asin">asin</a><a href="#method.asinh">asinh</a><a href="#method.atan">atan</a><a href="#method.atan2">atan2</a><a href="#method.atanh">atanh</a><a href="#method.cbrt">cbrt</a><a href="#method.ceil">ceil</a><a href="#method.classify">classify</a><a href="#method.cos">cos</a><a href="#method.cosh">cosh</a><a href="#method.div_euclid">div_euclid</a><a href="#method.exp">exp</a><a href="#method.expm1">expm1</a><a href="#method.floor">floor</a><a href="#method.fract">fract</a><a href="#method.is_finite">is_finite</a><a href="#method.is_infinite">is_infinite</a><a href="#method.is_nan">is_nan</a><a href="#method.is_normal">is_normal</a><a href="#method.is_sign_negative">is_sign_negative</a><a href="#method.is_sign_positive">is_sign_positive</a><a href="#method.is_subnormal">is_subnormal</a><a href="#method.is_zero">is_zero</a><a href="#method.ldexp">ldexp</a><a href="#method.ln">ln</a><a href="#method.ln1p">ln1p</a><a href="#method.log">log</a><a href="#method.log10">log10</a><a href="#method.log2">log2</a><a href="#method.new">new</a><a href="#method.nroot">nroot</a><a href="#method.powf">powf</a><a href="#method.powi">powi</a><a href="#method.recip">recip</a><a href="#method.rem_euclid">rem_euclid</a><a href="#method.round">round</a><a href="#method.signum">signum</a><a href="#method.sin">sin</a><a href="#method.sin_cos">sin_cos</a><a href="#method.sinh">sinh</a><a href="#method.sinh_cosh">sinh_cosh</a><a href="#method.sqr">sqr</a><a href="#method.sqrt">sqrt</a><a href="#method.tan">tan</a><a href="#method.tanh">tanh</a><a href="#method.trunc">trunc</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Add%3C%26%27_%20Double%3E">Add&lt;&amp;&#39;_ Double&gt;</a><a href="#impl-Add%3CDouble%3E">Add&lt;Double&gt;</a><a href="#impl-AddAssign%3C%26%27_%20Double%3E">AddAssign&lt;&amp;&#39;_ Double&gt;</a><a href="#impl-AddAssign%3CDouble%3E">AddAssign&lt;Double&gt;</a><a href="#impl-Clone">Clone</a><a href="#impl-Copy">Copy</a><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-Display">Display</a><a href="#impl-Div%3C%26%27_%20Double%3E">Div&lt;&amp;&#39;_ Double&gt;</a><a href="#impl-Div%3CDouble%3E">Div&lt;Double&gt;</a><a href="#impl-DivAssign%3C%26%27_%20Double%3E">DivAssign&lt;&amp;&#39;_ Double&gt;</a><a href="#impl-DivAssign%3CDouble%3E">DivAssign&lt;Double&gt;</a><a href="#impl-From%3C%26%27_%20str%3E">From&lt;&amp;&#39;_ str&gt;</a><a href="#impl-From%3C(f64%2C%20f64)%3E">From&lt;(f64, f64)&gt;</a><a href="#impl-From%3CDouble%3E">From&lt;Double&gt;</a><a href="#impl-From%3Cf32%3E">From&lt;f32&gt;</a><a href="#impl-From%3Cf64%3E">From&lt;f64&gt;</a><a href="#impl-From%3Ci16%3E">From&lt;i16&gt;</a><a href="#impl-From%3Ci32%3E">From&lt;i32&gt;</a><a href="#impl-From%3Ci64%3E">From&lt;i64&gt;</a><a href="#impl-From%3Ci8%3E">From&lt;i8&gt;</a><a href="#impl-From%3Cu16%3E">From&lt;u16&gt;</a><a href="#impl-From%3Cu32%3E">From&lt;u32&gt;</a><a href="#impl-From%3Cu64%3E">From&lt;u64&gt;</a><a href="#impl-From%3Cu8%3E">From&lt;u8&gt;</a><a href="#impl-FromStr">FromStr</a><a href="#impl-Index%3Cusize%3E">Index&lt;usize&gt;</a><a href="#impl-LowerExp">LowerExp</a><a href="#impl-Mul%3C%26%27_%20Double%3E">Mul&lt;&amp;&#39;_ Double&gt;</a><a href="#impl-Mul%3CDouble%3E">Mul&lt;Double&gt;</a><a href="#impl-MulAssign%3C%26%27_%20Double%3E">MulAssign&lt;&amp;&#39;_ Double&gt;</a><a href="#impl-MulAssign%3CDouble%3E">MulAssign&lt;Double&gt;</a><a href="#impl-Neg">Neg</a><a href="#impl-PartialEq%3CDouble%3E">PartialEq&lt;Double&gt;</a><a href="#impl-PartialOrd%3CDouble%3E">PartialOrd&lt;Double&gt;</a><a href="#impl-Product%3C%26%27a%20Double%3E">Product&lt;&amp;&#39;a Double&gt;</a><a href="#impl-Product%3CDouble%3E">Product&lt;Double&gt;</a><a href="#impl-Rem%3C%26%27_%20Double%3E">Rem&lt;&amp;&#39;_ Double&gt;</a><a href="#impl-Rem%3CDouble%3E">Rem&lt;Double&gt;</a><a href="#impl-RemAssign%3C%26%27_%20Double%3E">RemAssign&lt;&amp;&#39;_ Double&gt;</a><a href="#impl-RemAssign%3CDouble%3E">RemAssign&lt;Double&gt;</a><a href="#impl-Sub%3C%26%27_%20Double%3E">Sub&lt;&amp;&#39;_ Double&gt;</a><a href="#impl-Sub%3CDouble%3E">Sub&lt;Double&gt;</a><a href="#impl-SubAssign%3C%26%27_%20Double%3E">SubAssign&lt;&amp;&#39;_ Double&gt;</a><a href="#impl-SubAssign%3CDouble%3E">SubAssign&lt;Double&gt;</a><a href="#impl-Sum%3C%26%27a%20Double%3E">Sum&lt;&amp;&#39;a Double&gt;</a><a href="#impl-Sum%3CDouble%3E">Sum&lt;Double&gt;</a><a href="#impl-UpperExp">UpperExp</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-ToString">ToString</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class="location"><a href="index.html">qd</a></p><script>window.sidebarCurrent = {name: "Double", ty: "struct", relpath: ""};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/qd/double.rs.html#98" title="goto source code">[src]</a></span><span class="in-band">Struct <a href="index.html">qd</a>::<wbr><a class="struct" href="">Double</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust struct">pub struct Double(_, _);</pre></div><div class="docblock"><p>A 128-bit floating-point number implemented as the unevaluated sum of two 64-bit
floating-point numbers. Discarding the bits used for exponents, this makes for about
106 bits of mantissa accuracy, or around 31 decimal digits.</p>
<p>There are several ways to create a new <code>Double</code>:</p>
<ul>
<li>calling the <a href="#method.new"><code>new</code></a> function</li>
<li>calling <a href="#impl-From%3Cf64%3E"><code>from</code></a> with a primitive number (except for <code>u128</code> and <code>i128</code>) or a string</li>
<li>calling <a href="#impl-FromStr"><code>parse</code></a> on a string (or equivalently using <a href="#method.from_str"><code>from_str</code></a>)</li>
<li>using the <a href="macro.dd.html"><code>dd!</code></a> macro</li>
</ul>
<p>What kind of number you actually end up getting depends on the method called to get it.
<a href="#method.new"><code>new</code></a> will <em>not</em> normalize its result. This means that the arguments must be
pre-normalized. <a href="#impl-From%3Cf64%3E"><code>from</code></a>, <a href="#impl-FromStr"><code>parse</code></a>, and <a href="macro.dd.html"><code>dd!</code></a> will both account for floating-point
rounding error <em>and</em> produce normalized results.</p>
<p>The reason for these two different ways of going about creation is speed. If the number
is already pre-computed to take normalization and error into account (as all of the
constants in this library are), then <a href="#method.new"><code>new</code></a> offers a way to avoid having to pay the
efficiency cost of unnecessary normalization.</p>
<p>For the other methods, shortcuts can be taken if the input is a number and that number
is <a href="https://en.wikipedia.org/wiki/Dyadic_rational"><em>dyadic</em></a> (i.e., it can be represented in binary exactly, without rounding). In this
case, <a href="#impl-From%3Cf64%3E"><code>from</code></a> and <a href="macro.dd.html"><code>dd!</code></a> can also skip normalization and accounting for rounding, and
they won't be much slower than <a href="#method.new"><code>new</code></a>.</p>
<p>Parsing from strings or from numbers that are not dyadic cannot take these shortcuts.
The results will be precise, but at the cost of speed.</p>
<p>See the <a href="index.html">module-level documentation</a> for more information.</p>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><h3 id="impl" class="impl"><code class="in-band">impl <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl" class="anchor"></a><a class="srclink" href="../src/qd/double/aconsts.rs.html#9-164" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedconstant.RADIX" class="associatedconstant"><code>pub const <a href="#associatedconstant.RADIX" class="constant"><b>RADIX</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#12" title="goto source code">[src]</a></h4><div class="docblock"><p>The radix or base of the internal representation of <code>Double</code>. This is the same as
the representation in the underlying f64.</p>
</div><h4 id="associatedconstant.MANTISSA_DIGITS" class="associatedconstant"><code>pub const <a href="#associatedconstant.MANTISSA_DIGITS" class="constant"><b>MANTISSA_DIGITS</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#15" title="goto source code">[src]</a></h4><div class="docblock"><p>Number of significant digits in base 2.</p>
</div><h4 id="associatedconstant.DIGITS" class="associatedconstant"><code>pub const <a href="#associatedconstant.DIGITS" class="constant"><b>DIGITS</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#18" title="goto source code">[src]</a></h4><div class="docblock"><p>Approximate number of significant digits in base 10.</p>
</div><h4 id="associatedconstant.EPSILON" class="associatedconstant"><code>pub const <a href="#associatedconstant.EPSILON" class="constant"><b>EPSILON</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#25" title="goto source code">[src]</a></h4><div class="docblock"><p><a href="https://en.wikipedia.org/wiki/Machine_epsilon">Machine epsilon</a> value for <code>Double</code>.</p>
<p>This is the difference between <code>1.0</code> and the next largest representable number.</p>
</div><h4 id="associatedconstant.MIN" class="associatedconstant"><code>pub const <a href="#associatedconstant.MIN" class="constant"><b>MIN</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#28" title="goto source code">[src]</a></h4><div class="docblock"><p>Smallest finite <code>Double</code> value.</p>
</div><h4 id="associatedconstant.MIN_POSITIVE" class="associatedconstant"><code>pub const <a href="#associatedconstant.MIN_POSITIVE" class="constant"><b>MIN_POSITIVE</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#31" title="goto source code">[src]</a></h4><div class="docblock"><p>Smallest positive normal <code>Double</code> value.</p>
</div><h4 id="associatedconstant.MAX" class="associatedconstant"><code>pub const <a href="#associatedconstant.MAX" class="constant"><b>MAX</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#34" title="goto source code">[src]</a></h4><div class="docblock"><p>Largest finite <code>Double</code> value.</p>
</div><h4 id="associatedconstant.MIN_EXP" class="associatedconstant"><code>pub const <a href="#associatedconstant.MIN_EXP" class="constant"><b>MIN_EXP</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#37" title="goto source code">[src]</a></h4><div class="docblock"><p>One greater than the minimum possible normal power of 2 exponent.</p>
</div><h4 id="associatedconstant.MAX_EXP" class="associatedconstant"><code>pub const <a href="#associatedconstant.MAX_EXP" class="constant"><b>MAX_EXP</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#40" title="goto source code">[src]</a></h4><div class="docblock"><p>Maximum possible power of 2 exponent.</p>
</div><h4 id="associatedconstant.MIN_10_EXP" class="associatedconstant"><code>pub const <a href="#associatedconstant.MIN_10_EXP" class="constant"><b>MIN_10_EXP</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#43" title="goto source code">[src]</a></h4><div class="docblock"><p>Minimum possible normal power of 10 exponent.</p>
</div><h4 id="associatedconstant.MAX_10_EXP" class="associatedconstant"><code>pub const <a href="#associatedconstant.MAX_10_EXP" class="constant"><b>MAX_10_EXP</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#46" title="goto source code">[src]</a></h4><div class="docblock"><p>Maximum possible power of 10 exponent.</p>
</div><h4 id="associatedconstant.NAN" class="associatedconstant"><code>pub const <a href="#associatedconstant.NAN" class="constant"><b>NAN</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#49" title="goto source code">[src]</a></h4><div class="docblock"><p>Not a Number (NaN).</p>
</div><h4 id="associatedconstant.INFINITY" class="associatedconstant"><code>pub const <a href="#associatedconstant.INFINITY" class="constant"><b>INFINITY</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#52" title="goto source code">[src]</a></h4><div class="docblock"><p>Infinity ($\infin$).</p>
</div><h4 id="associatedconstant.NEG_INFINITY" class="associatedconstant"><code>pub const <a href="#associatedconstant.NEG_INFINITY" class="constant"><b>NEG_INFINITY</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#55" title="goto source code">[src]</a></h4><div class="docblock"><p>Negative infinity ($-\infin$).</p>
</div><h4 id="associatedconstant.ZERO" class="associatedconstant"><code>pub const <a href="#associatedconstant.ZERO" class="constant"><b>ZERO</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#58" title="goto source code">[src]</a></h4><div class="docblock"><p>Zero ($0$).</p>
</div><h4 id="associatedconstant.NEG_ZERO" class="associatedconstant"><code>pub const <a href="#associatedconstant.NEG_ZERO" class="constant"><b>NEG_ZERO</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#61" title="goto source code">[src]</a></h4><div class="docblock"><p>Negative zero ($-0$).</p>
</div><h4 id="associatedconstant.ONE" class="associatedconstant"><code>pub const <a href="#associatedconstant.ONE" class="constant"><b>ONE</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#64" title="goto source code">[src]</a></h4><div class="docblock"><p>One ($1$).</p>
</div><h4 id="associatedconstant.NEG_ONE" class="associatedconstant"><code>pub const <a href="#associatedconstant.NEG_ONE" class="constant"><b>NEG_ONE</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#67" title="goto source code">[src]</a></h4><div class="docblock"><p>Negative one ($-1$).</p>
</div><h4 id="associatedconstant.PI" class="associatedconstant"><code>pub const <a href="#associatedconstant.PI" class="constant"><b>PI</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#71" title="goto source code">[src]</a></h4><div class="docblock"><p>Archimedes' constant ($\pi$). The value of this constant is
3.141592653589793238462643383280.</p>
</div><h4 id="associatedconstant.TAU" class="associatedconstant"><code>pub const <a href="#associatedconstant.TAU" class="constant"><b>TAU</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#75" title="goto source code">[src]</a></h4><div class="docblock"><p>The full circle constant ($\tau$), or $2\pi$. The value of this constant is
6.283185307179586476925286766559.</p>
</div><h4 id="associatedconstant.FRAC_PI_2" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_PI_2" class="constant"><b>FRAC_PI_2</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#79" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\pi/2$. The value of this constant is
1.570796326794896619231321691640.</p>
</div><h4 id="associatedconstant.FRAC_PI_3" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_PI_3" class="constant"><b>FRAC_PI_3</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#83" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\pi/3$. The value of this constant is
1.047197551196597746154214461093.</p>
</div><h4 id="associatedconstant.FRAC_PI_4" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_PI_4" class="constant"><b>FRAC_PI_4</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#87" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\pi/4$. The value of this constant is
0.7853981633974483096156608458199.</p>
</div><h4 id="associatedconstant.FRAC_PI_6" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_PI_6" class="constant"><b>FRAC_PI_6</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#91" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\pi/6$. The value of this constant is
0.5235987755982988730771072305466.</p>
</div><h4 id="associatedconstant.FRAC_PI_8" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_PI_8" class="constant"><b>FRAC_PI_8</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#95" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\pi/8$. The value of this constant is
0.3926990816987241548078304229099.</p>
</div><h4 id="associatedconstant.FRAC_PI_16" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_PI_16" class="constant"><b>FRAC_PI_16</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#99" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\pi/16$. The value of this constant is
0.1963495408493620774039152114550.</p>
</div><h4 id="associatedconstant.FRAC_3_PI_2" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_3_PI_2" class="constant"><b>FRAC_3_PI_2</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#103" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $3\pi/2$. The value of this constant is
4.712388980384689857693965074919.</p>
</div><h4 id="associatedconstant.FRAC_3_PI_4" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_3_PI_4" class="constant"><b>FRAC_3_PI_4</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#107" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $3\pi/4$. The value of this constant is
2.356194490192344928846982537460.</p>
</div><h4 id="associatedconstant.FRAC_5_PI_4" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_5_PI_4" class="constant"><b>FRAC_5_PI_4</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#111" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $5\pi/4$. The value of this constant is
3.926990816987241548078304229099.</p>
</div><h4 id="associatedconstant.FRAC_7_PI_4" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_7_PI_4" class="constant"><b>FRAC_7_PI_4</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#115" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $7\pi/4$. The value of this constant is
5.497787143782138167309625920739.</p>
</div><h4 id="associatedconstant.FRAC_1_PI" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_1_PI" class="constant"><b>FRAC_1_PI</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#119" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $1/\pi$. The value of this constant is
0.3183098861837906715377675267450.</p>
</div><h4 id="associatedconstant.FRAC_2_PI" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_2_PI" class="constant"><b>FRAC_2_PI</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#123" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $2/\pi$. The value of this constant is
0.6366197723675813430755350534901.</p>
</div><h4 id="associatedconstant.FRAC_2_SQRT_PI" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_2_SQRT_PI" class="constant"><b>FRAC_2_SQRT_PI</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#127" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $2/\sqrt{\pi}$. The value of this constant is
1.128379167095512573896158903122.</p>
</div><h4 id="associatedconstant.SQRT_2" class="associatedconstant"><code>pub const <a href="#associatedconstant.SQRT_2" class="constant"><b>SQRT_2</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#131" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\sqrt{2}$. The value of this constant is
1.414213562373095048801688724210.</p>
</div><h4 id="associatedconstant.FRAC_1_SQRT_2" class="associatedconstant"><code>pub const <a href="#associatedconstant.FRAC_1_SQRT_2" class="constant"><b>FRAC_1_SQRT_2</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#135" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $1/\sqrt{2}$. The value of this constant is
0.7071067811865475244008443621048.</p>
</div><h4 id="associatedconstant.E" class="associatedconstant"><code>pub const <a href="#associatedconstant.E" class="constant"><b>E</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#139" title="goto source code">[src]</a></h4><div class="docblock"><p>Euler's number ($e$). The value of this constant is
2.718281828459045235360287471353.</p>
</div><h4 id="associatedconstant.LOG2_10" class="associatedconstant"><code>pub const <a href="#associatedconstant.LOG2_10" class="constant"><b>LOG2_10</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#143" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\log_2 10$. The value of this constant is
3.321928094887362347870319429489.</p>
</div><h4 id="associatedconstant.LOG2_E" class="associatedconstant"><code>pub const <a href="#associatedconstant.LOG2_E" class="constant"><b>LOG2_E</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#147" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\log_2 e$. The value of this constant is
1.442695040888963407359924681002.</p>
</div><h4 id="associatedconstant.LOG10_2" class="associatedconstant"><code>pub const <a href="#associatedconstant.LOG10_2" class="constant"><b>LOG10_2</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#151" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\log_{10} 2$. The value of this constant is
0.3010299956639811952137388947245.</p>
</div><h4 id="associatedconstant.LOG10_E" class="associatedconstant"><code>pub const <a href="#associatedconstant.LOG10_E" class="constant"><b>LOG10_E</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#155" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\log_{10} e$. The value of this constant is
0.4342944819032518276511289189166.</p>
</div><h4 id="associatedconstant.LN_2" class="associatedconstant"><code>pub const <a href="#associatedconstant.LN_2" class="constant"><b>LN_2</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#159" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\ln 2$. The value of this constant is
0.6931471805599453094172321214582.</p>
</div><h4 id="associatedconstant.LN_10" class="associatedconstant"><code>pub const <a href="#associatedconstant.LN_10" class="constant"><b>LN_10</b></a>: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/aconsts.rs.html#163" title="goto source code">[src]</a></h4><div class="docblock"><p>The constant $\ln 10$. The value of this constant is
2.302585092994045684017991454684.</p>
</div></div><h3 id="impl-1" class="impl"><code class="in-band">impl <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-1" class="anchor"></a><a class="srclink" href="../src/qd/double/alg.rs.html#11-439" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.ldexp" class="method"><code>pub fn <a href="#method.ldexp" class="fnname">ldexp</a>(self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/alg.rs.html#28-31" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates $x\sdot2^n$, where $x$ is <code>self</code> and $n$ is the argument.</p>
<p>Though this is not an everyday operation, it is often used in more advanced
mathematical calculations (including several within this library). Therefore an
implementation that is much more efficient than calculating it through
multiplication and <a href="#method.powi"><code>powi</code></a> is offered despite it not being part of the <code>f64</code> API.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">5</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">ldexp</span>(<span class="number">3</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">40</span>)); <span class="comment">// 5 * 2^3</span></pre></div>
</div><h4 id="method.agm" class="method"><code>pub fn <a href="#method.agm" class="fnname">agm</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/alg.rs.html#66-87" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the arithmetic-geometric mean of $x$ and $y$ ($M(x, y)$ or $\text{agm}(x,
y)$), where $x$ and $y$ are <code>self</code> and the argument.</p>
<p>The AGM is an iterative calculation. $x$ and $y$ are assigned as the two inputs to
the first iteration.</p>
<p>$$a_0 = x \newline g_0 = y$$</p>
<p>Then the iterations are performed as two interdependent sequences, one calculating
the arithmetic mean and one the geometric mean. The results from each iteration are
fed back into the next iteration as inputs.</p>
<p>$$a_{n + 1} = \frac{a_n + g_n}{2}$$
$$g_{n + 1} = \sqrt{a_{n}g_{n}}$$</p>
<p>These numbers both converge towards the same number, and once they reach that
number, it's returned as the AGM.</p>
<p>These sequences converge very quickly, doubling the accuracy with each iteration.
The AGM can be used in fast algorithms for transcendental functions and for
computing some mathematical constants (most notably $\pi$). The speed advantage from
its fast convergence is realized at around 400 decimal digits, so it isn't currently
used for these purposes in this library.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>.<span class="ident">agm</span>(<span class="ident">Double</span>::<span class="ident">PI</span>);
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;2.9261085515723046966658957101705574&quot;</span>);

<span class="kw">let</span> <span class="ident">delta</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.sqr" class="method"><code>pub fn <a href="#method.sqr" class="fnname">sqr</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/alg.rs.html#102-111" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the square of $x$, $x^2$, where $x$ is <code>self</code>.</p>
<p>This method takes advantage of optimizations in multiplication that are available
when the two numbers being multiplied are the same, so it is more efficient than
bare multiplication.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">sqr</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">x</span> <span class="op">*</span> <span class="ident">x</span>); <span class="comment">// The left side is faster though</span></pre></div>
</div><h4 id="method.sqrt" class="method"><code>pub fn <a href="#method.sqrt" class="fnname">sqrt</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/alg.rs.html#122-141" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the square root $x$, $\sqrt{x}$, where $x$ is <code>self</code>.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>).<span class="ident">sqrt</span>();
<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">Double</span>::<span class="ident">SQRT_2</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.nroot" class="method"><code>pub fn <a href="#method.nroot" class="fnname">nroot</a>(self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/alg.rs.html#155-183" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the $n$th root of $x$, $\sqrt[n]{x}$, where $x$ is <code>self</code> and $n$
is the argument.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>).<span class="ident">nroot</span>(<span class="number">4</span>);
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.1892071150027210667174999705605&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.cbrt" class="method"><code>pub fn <a href="#method.cbrt" class="fnname">cbrt</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/alg.rs.html#197-199" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the cube root of $x$, $\sqrt[3]{x}$, where $x$ is <code>self</code>.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>).<span class="ident">cbrt</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.2599210498948731647672106072782&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.powi" class="method"><code>pub fn <a href="#method.powi" class="fnname">powi</a>(self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/alg.rs.html#219-248" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates $x$ raised to the integer power $n$, $x^n$, where $x$ is <code>self</code> and
$n$ is the argument.</p>
<p>This function correctly handles the special inputs defined in IEEE 754. In
particular:</p>
<ul>
<li><code>x.powi(0)</code> is $1$ for any <code>x</code> (including <code>0</code>, <code>NaN</code>, or <code>inf</code>)</li>
<li><code>x.powi(n)</code> is $\pm\infin$ for <code>x</code> = $\pm0$ and any odd negative <code>n</code></li>
<li><code>x.powi(n)</code> is $+\infin$ for <code>x</code> = $\pm0$ and any even negative <code>n</code></li>
<li><code>x.powi(n)</code> is $\pm0$ for <code>x</code> = $\pm0$ and any odd positive <code>n</code></li>
<li><code>x.powi(n)</code> is $+0$ for <code>x</code> = $\pm0$ and any even positive <code>n</code></li>
</ul>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">powi</span>(<span class="number">3</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">27</span>));</pre></div>
</div><h4 id="method.powf" class="method"><code>pub fn <a href="#method.powf" class="fnname">powf</a>(self, n: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/alg.rs.html#278-283" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates $x$ raised to the <code>Double</code> power $n$, $x^n$, where $x$ is <code>self</code>
and $n$ is the argument.</p>
<p>In general, $x^n$ is equal to $e^{n \ln x}$. This precludes raising a negative
<code>Double</code> to a fractional or irrational power because $\ln x$ is undefined when $x$
is negative. In that case, this function returns <a href="#associatedconstant.NAN"><code>NAN</code></a>.</p>
<p>It's actually more complex than that; if the exponent can be expressed as a fraction
with an odd denominator, then there is an answer ($\sqrt[3]{x}$, which is defined
for negative $x$, is the same as a $x^\frac{1}{3}$). Therefore, something like
<code>dd!(-4).powf(dd!(0.2))</code> should work, as 0.2 is a fraction with an odd denominator
($\frac{1}{5}$), and the entire expression is the same as $\sqrt[5]{-4}$, which is
a real thing. However, it's impossible in general to tell whether a number is a
fraction while using floating-point numbers, so no attempt is made to make this
work. If you need a fifth root of 4, use <code>dd!(-4).nroot(5)</code>.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>).<span class="ident">powf</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="number">3.3</span>));
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;37.540507598529552193101865954634&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-28</span>));</pre></div>
</div><h4 id="method.recip" class="method"><code>pub fn <a href="#method.recip" class="fnname">recip</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/alg.rs.html#297-299" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the reciprocal of $x$, $\frac{1}{x}$, where $x$ is <code>self</code>.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>.<span class="ident">recip</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.31830988618379067153776752674503&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-2" class="impl"><code class="in-band">impl <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-2" class="anchor"></a><a class="srclink" href="../src/qd/double/arith.rs.html#8-68" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.rem_euclid" class="method"><code>pub fn <a href="#method.rem_euclid" class="fnname">rem_euclid</a>(self, rhs: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/arith.rs.html#29-32" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the least non-negative remainder of $x \div y$, where $x$ is <code>self</code> and
$y$ is the argument. This is $x \mod y$ using the Euclidean definition of the modulo
operation.</p>
<p>In principle, the returned value $r$ will satisfy $0 \le r &lt; |y|$; it will be
non-negative and less than the absolute value of the argument. However, in extreme
cases, $r$ may equal $|y|$ because of floating-point rounding error.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">21</span>);
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">rem_euclid</span>(<span class="ident">y</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>));
<span class="macro">assert</span><span class="macro">!</span>((<span class="op">-</span><span class="ident">x</span>).<span class="ident">rem_euclid</span>(<span class="ident">y</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">rem_euclid</span>(<span class="op">-</span><span class="ident">y</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>));
<span class="macro">assert</span><span class="macro">!</span>((<span class="op">-</span><span class="ident">x</span>).<span class="ident">rem_euclid</span>(<span class="op">-</span><span class="ident">y</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>));</pre></div>
</div><h4 id="method.div_euclid" class="method"><code>pub fn <a href="#method.div_euclid" class="fnname">div_euclid</a>(self, rhs: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/arith.rs.html#56-67" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the quotient in the Euclidean division $x \div y$, where $x$ is <code>self</code>
and $y$ is the argument.</p>
<p>The Euclidean quotient is <code>x / y</code> rounded to the integer <code>n</code> such that <code>x &gt;= n * y</code>.
That makes it the counterpart to <a href="#method.rem_euclid"><code>rem_euclid</code></a> in the same way that regular
division is the counterpart to the <code>%</code> operator; the answer <code>n</code> that it computes is
the integer such that <code>x = n * y + x.rem_euclid(y)</code>.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">21</span>);
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">div_euclid</span>(<span class="ident">y</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">5</span>));
<span class="macro">assert</span><span class="macro">!</span>((<span class="op">-</span><span class="ident">x</span>).<span class="ident">div_euclid</span>(<span class="ident">y</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">6</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">div_euclid</span>(<span class="op">-</span><span class="ident">y</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">5</span>));
<span class="macro">assert</span><span class="macro">!</span>((<span class="op">-</span><span class="ident">x</span>).<span class="ident">div_euclid</span>(<span class="op">-</span><span class="ident">y</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">6</span>));</pre></div>
</div></div><h3 id="impl-3" class="impl"><code class="in-band">impl <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-3" class="anchor"></a><a class="srclink" href="../src/qd/double/hyper.rs.html#14-321" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.sinh_cosh" class="method"><code>pub fn <a href="#method.sinh_cosh" class="fnname">sinh_cosh</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>, <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a></code><a class="srclink" href="../src/qd/double/hyper.rs.html#41-58" title="goto source code">[src]</a></h4><div class="docblock"><p>Simultaneously computes the hyperbolic sine and cosine of $x$, $\sinh x$ and $\cosh
x$, where $x$ is <code>self</code>.</p>
<p>The domain of this function is $(-\infin, \infin)$, and the range is $(-\infin,
\infin)$ for the first component of the answer (the hyperbolic sine) and $[1,
\infin)$ for the second (the hyperbolic cosine).</p>
<p>This method is more efficient to run than <a href="#method.sinh"><code>sinh</code></a> and <a href="#method.cosh"><code>cosh</code></a> individually and is
useful when both numbers are needed.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> (<span class="ident">sin_h</span>, <span class="ident">cos_h</span>) <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>).<span class="ident">sinh_cosh</span>();
<span class="kw">let</span> <span class="ident">esin</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.1752011936438014568823818505956&quot;</span>);
<span class="kw">let</span> <span class="ident">ecos</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.5430806348152437784779056207571&quot;</span>);

<span class="kw">let</span> <span class="ident">diff1</span> <span class="op">=</span> (<span class="ident">sin_h</span> <span class="op">-</span> <span class="ident">esin</span>).<span class="ident">abs</span>();
<span class="kw">let</span> <span class="ident">diff2</span> <span class="op">=</span> (<span class="ident">cos_h</span> <span class="op">-</span> <span class="ident">ecos</span>).<span class="ident">abs</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff1</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff2</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.sinh" class="method"><code>pub fn <a href="#method.sinh" class="fnname">sinh</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/hyper.rs.html#75-104" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the hyperbolic sine of $x$, $\sinh x$, where $x$ is <code>self</code>.</p>
<p>The domain and range of this function are both $(-\infin, \infin)$. Large values
will start to cause a loss of precision; by the time the number is $\pm130$ or so,
precision is down to 29 digits.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>).<span class="ident">sinh</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.1752011936438014568823818505956&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.cosh" class="method"><code>pub fn <a href="#method.cosh" class="fnname">cosh</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/hyper.rs.html#119-127" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the hyperbolic cosine of $x$, $\cosh x$, where $x$ is <code>self</code>.</p>
<p>The domain of this function is $(-\infin, \infin)$, and the range is $[1, \infin)$.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>).<span class="ident">cosh</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.5430806348152437784779056207571&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.tanh" class="method"><code>pub fn <a href="#method.tanh" class="fnname">tanh</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/hyper.rs.html#142-156" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the hyperbolic tangent of $x$, $\tanh x$, where $x$ is <code>self</code>.</p>
<p>The domain of this function is $(-\infin, \infin)$, and the range is $(-1, 1)$.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>).<span class="ident">tanh</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.76159415595576488811945828260479&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.asinh" class="method"><code>pub fn <a href="#method.asinh" class="fnname">asinh</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/hyper.rs.html#171-176" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the inverse hyperbolic sine of $x$, $\sinh^{-1} x$, where $x$ is <code>self</code>.</p>
<p>The domain and range of this function are both $(-\infin, \infin)$.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1.5</span>).<span class="ident">asinh</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.1947632172871093041119308285191&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.acosh" class="method"><code>pub fn <a href="#method.acosh" class="fnname">acosh</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/hyper.rs.html#195-200" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the inverse hyperbolic cosine of $x$, $\cosh^{-1} x$, where $x$ is
<code>self</code>.</p>
<p>The domain of the function is $[1, \infin)$ and the range is $[0, \infin)$. Any
argument outside the range will result in <a href="#associatedconstant.NAN"><code>NAN</code></a>.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1.5</span>).<span class="ident">acosh</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.96242365011920689499551782684874&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.atanh" class="method"><code>pub fn <a href="#method.atanh" class="fnname">atanh</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/hyper.rs.html#219-224" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the inverse hyperbolic tangent of $x$, $\tanh^{-1} x$, where $x$ is
<code>self</code>.</p>
<p>The domain of the function is $(-1, 1)$ and the range is $(-\infin, \infin)$. Any
argument whose absolute value is greater than or equal to 1 will result in <a href="#associatedconstant.NAN"><code>NAN</code></a>.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">0.5</span>).<span class="ident">atanh</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.54930614433405484569762261846126&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-4" class="impl"><code class="in-band">impl <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-4" class="anchor"></a><a class="srclink" href="../src/qd/double/misc.rs.html#11-369" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.abs" class="method"><code>pub fn <a href="#method.abs" class="fnname">abs</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#23-29" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the absolute value of $x$, $|x|$, where $x$ is <code>self</code>. The absolute value
of $x$ is simply the same value as $x$, but with the opposite sign if $x$ is
negative.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>).<span class="ident">abs</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3</span>).<span class="ident">abs</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>));</pre></div>
</div><h4 id="method.floor" class="method"><code>pub fn <a href="#method.floor" class="fnname">floor</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#49-58" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the floor of $x$, $\lfloor{x}\rfloor$, where $x$ is <code>self</code>.</p>
<p>The floor of $x$ is the largest integer value less than or equal to $x$. This means
that the floor of a negative number will have an absolute value greater than that of
the number itself.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3.99</span>);
<span class="kw">let</span> <span class="ident">g</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3.0</span>);
<span class="kw">let</span> <span class="ident">h</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3.99</span>);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">f</span>.<span class="ident">floor</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">g</span>.<span class="ident">floor</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">h</span>.<span class="ident">floor</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">4</span>));</pre></div>
</div><h4 id="method.ceil" class="method"><code>pub fn <a href="#method.ceil" class="fnname">ceil</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#78-87" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the ceiling of $x$, $\lceil{x}\rceil$, where $x$ is <code>self</code>.</p>
<p>The ceiling of $x$ is the smallest integer value greater than or equal to $x$. This
means that the ceiling of a negative number will have an absolute value the same as
(not greater than) that of the number itself.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3.01</span>);
<span class="kw">let</span> <span class="ident">g</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4.0</span>);
<span class="kw">let</span> <span class="ident">h</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3.01</span>);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">f</span>.<span class="ident">ceil</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">g</span>.<span class="ident">ceil</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">h</span>.<span class="ident">ceil</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3</span>));</pre></div>
</div><h4 id="method.round" class="method"><code>pub fn <a href="#method.round" class="fnname">round</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#107-119" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the rounded value of $x$, where $x$ is <code>self</code>.</p>
<p>The rounded value is the nearest integer to $x$. Halfway cases (i.e., numbers with a
fractional portion of <code>0.5</code>) are rounded away from <code>0</code>, per the behavior of <code>f64</code>'s
<code>round</code> function.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3.3</span>);
<span class="kw">let</span> <span class="ident">g</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3.5</span>);
<span class="kw">let</span> <span class="ident">h</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3.3</span>);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">f</span>.<span class="ident">round</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">g</span>.<span class="ident">round</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">h</span>.<span class="ident">round</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3</span>));</pre></div>
</div><h4 id="method.trunc" class="method"><code>pub fn <a href="#method.trunc" class="fnname">trunc</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#134-140" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the integer part of <code>self</code>. This integer part will be of the same sign as
the original number.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3.3</span>);
<span class="kw">let</span> <span class="ident">g</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3.7</span>);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">f</span>.<span class="ident">trunc</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">g</span>.<span class="ident">trunc</span>() <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3</span>));</pre></div>
</div><h4 id="method.fract" class="method"><code>pub fn <a href="#method.fract" class="fnname">fract</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#158-160" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the fractional part of the <code>self</code>. This fractional part will be of the same
sign as the original number.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3.3</span>);
<span class="kw">let</span> <span class="ident">g</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3.7</span>);

<span class="kw">let</span> <span class="ident">fdiff</span> <span class="op">=</span> (<span class="ident">f</span>.<span class="ident">fract</span>() <span class="op">-</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">0.3</span>)).<span class="ident">abs</span>();
<span class="kw">let</span> <span class="ident">gdiff</span> <span class="op">=</span> (<span class="ident">g</span>.<span class="ident">fract</span>() <span class="op">-</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">0.7</span>)).<span class="ident">abs</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">fdiff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">gdiff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.signum" class="method"><code>pub fn <a href="#method.signum" class="fnname">signum</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#182-190" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a number that represents the sign of <code>self</code>.</p>
<ul>
<li><a href="#associatedconstant.ONE"><code>ONE</code></a> if <code>self</code> is positive, including <code>+0.0</code> and <a href="#associatedconstant.INFINITY"><code>INFINITY</code></a></li>
<li><a href="#associatedconstant.NEG_ONE"><code>NEG_ONE</code></a> if <code>self</code> is negative, including <code>-0.0</code> and <a href="#associatedconstant.NEG_INFINITY"><code>NEG_INFINITY</code></a></li>
<li><a href="#associatedconstant.NAN"><code>NAN</code></a> if <code>self</code> is <a href="#associatedconstant.NAN"><code>NAN</code></a></li>
</ul>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="number">3.5</span>).<span class="ident">signum</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">ONE</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">NEG_INFINITY</span>.<span class="ident">signum</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">NEG_ONE</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">NAN</span>.<span class="ident">signum</span>().<span class="ident">is_nan</span>());</pre></div>
</div><h4 id="method.classify" class="method"><code>pub fn <a href="#method.classify" class="fnname">classify</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/num/enum.FpCategory.html" title="enum core::num::FpCategory">FpCategory</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#221-230" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>self</code>'s floating point category.</p>
<p>The possible return values are the members of <a href="https://doc.rust-lang.org/std/num/enum.FpCategory.html"><code>FpCategory</code></a>, as follows:</p>
<ul>
<li><code>FpCategory::Zero</code> if the number is $\pm0$;</li>
<li><code>FpCategory::Infinite</code> if the number is $\pm\infin$;</li>
<li><code>FpCategory::Nan</code> if the number is not a number;</li>
<li><code>FpCategory::Subnormal</code> if the number is $\pm$<a href="#associatedconstant.MIN_POSITIVE"><code>MIN_POSITIVE</code></a> (numbers this small
can be represented, but they lose some accuracy);</li>
<li><code>FpCategory::Normal</code> if the number is anything else.</li>
</ul>
<p>A <code>Double</code> can also register as <code>FpCategory::Subnormal</code> if it has a small enough
negative exponent that the second component of the number is a subnormal number
itself. This will typically happen around <code>1e-292</code> or so.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">num</span>::<span class="ident">FpCategory</span>;

<span class="kw">let</span> <span class="ident">num</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">12.4</span>);
<span class="kw">let</span> <span class="ident">inf</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">INFINITY</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">num</span>.<span class="ident">classify</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">FpCategory</span>::<span class="ident">Normal</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">inf</span>.<span class="ident">classify</span>() <span class="op">=</span><span class="op">=</span> <span class="ident">FpCategory</span>::<span class="ident">Infinite</span>);</pre></div>
</div><h4 id="method.is_normal" class="method"><code>pub fn <a href="#method.is_normal" class="fnname">is_normal</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#252-254" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>self</code> is neither zero, infinite, subnormal, or <code>NaN</code>.</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">min</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">MIN_POSITIVE</span>;
<span class="kw">let</span> <span class="ident">max</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">MAX</span>;
<span class="kw">let</span> <span class="ident">lower</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-308</span>);
<span class="kw">let</span> <span class="ident">zero</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">ZERO</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">min</span>.<span class="ident">is_normal</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">max</span>.<span class="ident">is_normal</span>());

<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">zero</span>.<span class="ident">is_normal</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Double</span>::<span class="ident">NAN</span>.<span class="ident">is_normal</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Double</span>::<span class="ident">INFINITY</span>.<span class="ident">is_normal</span>());
<span class="comment">// Values between `0` and `MIN_POSITIVE` are subnormal.</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">lower</span>.<span class="ident">is_normal</span>());</pre></div>
</div><h4 id="method.is_zero" class="method"><code>pub fn <a href="#method.is_zero" class="fnname">is_zero</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#266-268" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>self</code> is either positive or negative zero.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">ZERO</span>.<span class="ident">is_zero</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">NEG_ZERO</span>.<span class="ident">is_zero</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Double</span>::<span class="ident">PI</span>.<span class="ident">is_zero</span>());</pre></div>
</div><h4 id="method.is_sign_negative" class="method"><code>pub fn <a href="#method.is_sign_negative" class="fnname">is_sign_negative</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#283-285" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>self</code> is negative, including negative zero, negative infinity,
and <code>NaN</code> with a negative sign bit.</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">NEG_ZERO</span>.<span class="ident">is_sign_negative</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">NEG_INFINITY</span>.<span class="ident">is_sign_negative</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">7.0</span>).<span class="ident">is_sign_negative</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Double</span>::<span class="ident">ZERO</span>.<span class="ident">is_sign_negative</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="macro">dd</span><span class="macro">!</span>(<span class="number">7.0</span>).<span class="ident">is_sign_negative</span>());</pre></div>
</div><h4 id="method.is_sign_positive" class="method"><code>pub fn <a href="#method.is_sign_positive" class="fnname">is_sign_positive</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#300-302" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>self</code> is positive, including positive zero, positive infinity and
<code>NaN</code> with a positive sign bit.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">ZERO</span>.<span class="ident">is_sign_positive</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">INFINITY</span>.<span class="ident">is_sign_positive</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="number">7.0</span>).<span class="ident">is_sign_positive</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Double</span>::<span class="ident">NEG_ZERO</span>.<span class="ident">is_sign_positive</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">7.0</span>).<span class="ident">is_sign_positive</span>());</pre></div>
</div><h4 id="method.is_nan" class="method"><code>pub fn <a href="#method.is_nan" class="fnname">is_nan</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#316-318" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>self</code> is <code>NaN</code>.</p>
<p>This is the proper way to test for <code>NaN</code> because it cannot be done with an equality
test (since <code>NaN</code> is not equal to itself).</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">NAN</span>.<span class="ident">is_nan</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="macro">dd</span><span class="macro">!</span>(<span class="number">7.0</span>).<span class="ident">is_nan</span>());</pre></div>
</div><h4 id="method.is_infinite" class="method"><code>pub fn <a href="#method.is_infinite" class="fnname">is_infinite</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#331-333" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>self</code> is positive or negative infinity.</p>
<h1 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">INFINITY</span>.<span class="ident">is_infinite</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">NEG_INFINITY</span>.<span class="ident">is_infinite</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Double</span>::<span class="ident">NAN</span>.<span class="ident">is_infinite</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="macro">dd</span><span class="macro">!</span>(<span class="number">7.0</span>).<span class="ident">is_infinite</span>());</pre></div>
</div><h4 id="method.is_finite" class="method"><code>pub fn <a href="#method.is_finite" class="fnname">is_finite</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#346-348" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>self</code> is neither infinite nor <code>NaN</code>.</p>
<h1 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Double</span>::<span class="ident">INFINITY</span>.<span class="ident">is_finite</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Double</span>::<span class="ident">NEG_INFINITY</span>.<span class="ident">is_finite</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Double</span>::<span class="ident">NAN</span>.<span class="ident">is_finite</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="number">7.0</span>).<span class="ident">is_finite</span>());</pre></div>
</div><h4 id="method.is_subnormal" class="method"><code>pub fn <a href="#method.is_subnormal" class="fnname">is_subnormal</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/qd/double/misc.rs.html#366-368" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has an absolute value of less than <a href="#associatedconstant.MIN_POSITIVE"><code>MIN_POSITIVE</code></a>.</p>
<p>Numbers this small can be represented by floating point numbers, but they are not as
accurate. This inaccuracy is inherent in the IEEE-754 format for 64-bit numbers;
making a double-double out of an inaccurate number means the double-double is also
going to be inaccurate.</p>
<h1 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">Double</span>::<span class="ident">PI</span>.<span class="ident">is_subnormal</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-308</span>).<span class="ident">is_subnormal</span>());</pre></div>
</div></div><h3 id="impl-5" class="impl"><code class="in-band">impl <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-5" class="anchor"></a><a class="srclink" href="../src/qd/double/trans.rs.html#16-605" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.exp" class="method"><code>pub fn <a href="#method.exp" class="fnname">exp</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trans.rs.html#41-146" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the exponential function, $e^x$, where $x$ is <code>self</code>.</p>
<p>The result of this function grows rapidly. Once $x$ exceeds 708, the result is too
large to represent with a <code>Double</code>; at that point the function begins to return
<a href="#associatedconstant.INFINITY"><code>INFINITY</code></a>. The limit on the low end is less due to the fact that the second
component needs to fit in an <code>f64</code> rather than the first, along with extra bits used
in argument reduction; this function begins to return 0 at -600.</p>
<p>As $x$ grows this function does lose a bit of precision. It's precise to at least 30
digits up to values of $-140 \le x \le 150$, and from then until the limits, it's
precise to at least 29 digits.</p>
<h1 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>).<span class="ident">exp</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;7.3890560989306502272304274605750057&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-29</span>));</pre></div>
</div><h4 id="method.expm1" class="method"><code>pub fn <a href="#method.expm1" class="fnname">expm1</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trans.rs.html#190-276" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the exponential function of $x$ minus 1, $e^x - 1$, where $x$ is <code>self</code>.</p>
<p>While this function literally calculates the value returned by <a href="#method.exp"><code>exp</code></a> minus 1, it
does this directly (rather than computing <a href="#method.exp"><code>exp</code></a> directly and then subtracting 1
from the answer). This is useful in the not-infrequent case where $x$ is very close
to 0 and you have to subtract something near 1 from the answer (another example is
<code>x.exp() - x.cos()</code> — for very small values of <code>x</code>, <code>x.cos()</code> is also very
near 1). Since <code>x.exp()</code> is very close to 1 when <code>x</code> is very close to 0, this is
subtracting something very close to 1 from something else very close to 1.</p>
<p>When this happens, subtracting 1 from <a href="#method.exp"><code>exp</code></a> suffers from <a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">catastrophic
cancellation</a>, a condition in which subtracting two numbers that are very close to
each other can result in a huge loss of accuracy. Since <code>expm1</code> does not perform
this subtraction but instead computes <em>e</em><sup>x</sup> - 1 directly, it does not
suffer from this phenomenon.</p>
<p>This function will work over the same range as <a href="#method.exp"><code>exp</code></a>, but <code>x.expm1() + 1</code> has no
advantage over <code>x.exp()</code>. It's for that one very particular purpose.</p>
<h1 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// A value very close to 0.</span>
<span class="kw">let</span> <span class="ident">v_small</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-28</span>);
<span class="comment">// The actual value of exp(v_small) - 1. The last digit is on the order of 1e-62.</span>
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.0000000000000000000000000000500003e-28&quot;</span>);

<span class="comment">// First with exp, subtracting one from the result. The resulting precision loses at</span>
<span class="comment">// least 14 digits, making it no better than f64 precision.</span>
<span class="kw">let</span> <span class="ident">exp</span> <span class="op">=</span> <span class="ident">v_small</span>.<span class="ident">exp</span>() <span class="op">-</span> <span class="ident">Double</span>::<span class="ident">ONE</span>;
<span class="kw">let</span> <span class="ident">eps</span> <span class="op">=</span> (<span class="ident">exp</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">eps</span> <span class="op">&gt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-46</span>));

<span class="comment">// Next with expm1. Since this is calculated without subtracting one from anything,</span>
<span class="comment">// the catastrophic cancellation does not occur and full precision is maintained.</span>
<span class="kw">let</span> <span class="ident">expm1</span> <span class="op">=</span> <span class="ident">v_small</span>.<span class="ident">expm1</span>();
<span class="kw">let</span> <span class="ident">epsm1</span> <span class="op">=</span> (<span class="ident">expm1</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">epsm1</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-60</span>));</pre></div>
</div><h4 id="method.ln" class="method"><code>pub fn <a href="#method.ln" class="fnname">ln</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trans.rs.html#304-342" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the base-$e$ (natural) logarithm of $x$, $\ln x$ or $\log_e x$, where $x$
is <code>self</code>.</p>
<p>This calculation relies upon the <a href="#method.exp"><code>exp</code></a> calculation, in the opposite direction. A
large positive logarithm, for example, will require the calculation of a large
negative exponential.</p>
<p>For the same reasons that negative values of <a href="#method.exp"><code>exp</code></a> are limited to -600, the
accurate results of this function are limited to the number whose logarithm is 600,
which is around <code>2.65e261</code>. Take care with this; unlike in <a href="#method.exp"><code>exp</code></a>, <a href="#associatedconstant.INFINITY"><code>INFINITY</code></a> is
<em>not</em> returned. In that function, exceeding the maximum refers to actually
overflowing an <code>f64</code>, which is appropriate to call <a href="#associatedconstant.INFINITY"><code>INFINITY</code></a>; here, it means
<code>601</code>.</p>
<h1 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">7</span>).<span class="ident">ln</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.9459101490553133051053527434432&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-29</span>));</pre></div>
</div><h4 id="method.ln1p" class="method"><code>pub fn <a href="#method.ln1p" class="fnname">ln1p</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trans.rs.html#389-438" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the base-$e$ (natural) logarithm of 1 plus $x$, $\ln (1 + x)$ or $\log_e
(1 + x)$, where $x$ is <code>self</code>.</p>
<p>This is the inverse of <a href="#method.expm1"><code>expm1</code></a> and arises from the same sorts of concerns. It
isn't unusual to want to take logarithms of numbers very near 1, as the logarithm
approaches 0 at that point. However, with finite-precision mathematics, the <code>1</code>
itself severely limits the precision possible; the number <code>1.000000000000001</code> has 16
digits of precision, but most of them are taken up by placeholder zeros when we
would prefer to have that precision available after the final <code>1</code>.</p>
<p><code>ln1p</code> allows that by letting the user pass in a number near 0 and having the
algorithm add 1 to it internally, without causing the loss of precision. For
example, the same 16-digit number above could be passed into <code>ln1p</code> as
<code>0.000000000000001</code>, a number with <em>one</em> digit of precision, leaving 15 more digits
of precision availble after that final <code>1</code>.</p>
<p>The algorithm for logarithms close to 1 is slower than that for the general
logarithm, so this function delegates to <a href="#method.ln"><code>ln</code></a> if it can be done without losing
precision. There is no advantage to using <code>ln1p</code> over <a href="#method.ln"><code>ln</code></a> except for computing
logarithms of numbers very close to 1.</p>
<h1 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// A very small number</span>
<span class="kw">let</span> <span class="ident">v_small</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-200</span>);
<span class="comment">// The actual value for the base-e logarithm of 1 + 1e-200</span>
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.0000000000000000000000000000000004e-200&quot;</span>);

<span class="comment">// First with ln, computing the logarithm of 1 + 1e-200. This loses at least 14</span>
<span class="comment">// digits of precision because of the precision-damping effect of adding the one</span>
<span class="comment">// before the computation.</span>
<span class="kw">let</span> <span class="ident">ln</span> <span class="op">=</span> (<span class="ident">Double</span>::<span class="ident">ONE</span> <span class="op">+</span> <span class="ident">v_small</span>).<span class="ident">ln</span>();
<span class="kw">let</span> <span class="ident">lneps</span> <span class="op">=</span> (<span class="ident">ln</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">lneps</span> <span class="op">&gt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-217</span>));

<span class="comment">// Now with ln1p, computing the same logarithm. This does not suffer from the same</span>
<span class="comment">// effect from the 1, and the answer retains full precision.</span>
<span class="kw">let</span> <span class="ident">ln1p</span> <span class="op">=</span> <span class="ident">v_small</span>.<span class="ident">ln1p</span>();
<span class="kw">let</span> <span class="ident">ln1peps</span> <span class="op">=</span> (<span class="ident">ln1p</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">ln1peps</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-231</span>));</pre></div>
</div><h4 id="method.log10" class="method"><code>pub fn <a href="#method.log10" class="fnname">log10</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trans.rs.html#460-462" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the base-10 logarithm of $x$, $\log_{10} x$, where $x$ is <code>self</code>.</p>
<p>As with <a href="#method.ln"><code>ln</code></a>, this has an upper usable range less than the size of the numbers
themselves. In this case, that upper limit is around <code>1e261</code>. Over this number, the
output is not reliable, but it does not return <a href="#associatedconstant.INFINITY"><code>INFINITY</code></a> because the number 261
is so plainly not infinite.</p>
<h1 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>.<span class="ident">log10</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.434294481903251827651128918916605&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.log2" class="method"><code>pub fn <a href="#method.log2" class="fnname">log2</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trans.rs.html#483-485" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the base-2 logarithm of $x$, $\log_2 x$, where $x$ is <code>self</code>.</p>
<p>Since 2 is smaller than $e$, this function is constrained even more than <a href="#method.ln"><code>ln</code></a>. It
will start returning <a href="#associatedconstant.NEG_INFINITY"><code>NEG_INFINITY</code></a> at around <code>1e-213</code> and will start to fail on
the positive side at around <code>2.6e180</code>.</p>
<h1 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">10</span>).<span class="ident">log2</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;3.32192809488736234787031942948939&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-29</span>));</pre></div>
</div><h4 id="method.log" class="method"><code>pub fn <a href="#method.log" class="fnname">log</a>(self, b: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trans.rs.html#511-516" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates the base-$b$ logarithm of $x$, $\log_b x$, where $x$ is <code>self</code> and $b$ is
the argument.</p>
<p>This function will have limits at extreme arguments like the other logarithm
functions. The difference is that those limits will depend on the base argument.</p>
<p>If the goal is to calculate the base-$e$, base-2, or base-10 logarithms of $x$, the
specialized functions for those purposes (<a href="#method.ln"><code>ln</code></a>, <a href="#method.log2"><code>log2</code></a>, and <a href="#method.log10"><code>log10</code></a>
respectively) will be more efficient.</p>
<h1 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">10</span>).<span class="ident">log</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="number">7.0</span>));
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;1.18329466245493832681792856164686&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-29</span>));</pre></div>
</div></div><h3 id="impl-6" class="impl"><code class="in-band">impl <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-6" class="anchor"></a><a class="srclink" href="../src/qd/double/trig.rs.html#9-462" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.sin_cos" class="method"><code>pub fn <a href="#method.sin_cos" class="fnname">sin_cos</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>, <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a></code><a class="srclink" href="../src/qd/double/trig.rs.html#30-59" title="goto source code">[src]</a></h4><div class="docblock"><p>Simultaneously computes the sine and cosine of $x$, $\sin x$ and $\cos x$, where $x$
is <code>self</code>. This is more efficient than calling the separate <a href="#method.sin"><code>sin</code></a> and <a href="#method.cos"><code>cos</code></a>
functions if you need both numbers.</p>
<h1 id="examples-41" class="section-header"><a href="#examples-41">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">/</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>);
<span class="kw">let</span> (<span class="ident">sin_x</span>, <span class="ident">cos_x</span>) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">sin_cos</span>();

<span class="kw">let</span> <span class="ident">diff_sin</span> <span class="op">=</span> (<span class="ident">sin_x</span> <span class="op">-</span> <span class="ident">x</span>.<span class="ident">sin</span>()).<span class="ident">abs</span>();
<span class="kw">let</span> <span class="ident">diff_cos</span> <span class="op">=</span> (<span class="ident">cos_x</span> <span class="op">-</span> <span class="ident">x</span>.<span class="ident">cos</span>()).<span class="ident">abs</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff_sin</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff_cos</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.sin" class="method"><code>pub fn <a href="#method.sin" class="fnname">sin</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trig.rs.html#75-121" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the sine of $x$, $\sin x$, where $x$ is <code>self</code>.</p>
<p>The domain of this function is $(-\infin, \infin)$, and the range is $[-1, 1]$.</p>
<h1 id="examples-42" class="section-header"><a href="#examples-42">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> (<span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">/</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>)).<span class="ident">sin</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.cos" class="method"><code>pub fn <a href="#method.cos" class="fnname">cos</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trig.rs.html#137-174" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the cosine of $x$, $\cos x$, where $x$ is <code>self</code>.</p>
<p>The domain of this function is $(-\infin, \infin)$, and the range is $[-1, 1]$.</p>
<h1 id="examples-43" class="section-header"><a href="#examples-43">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> (<span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">/</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>)).<span class="ident">cos</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">0</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.tan" class="method"><code>pub fn <a href="#method.tan" class="fnname">tan</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trig.rs.html#189-192" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the tangent of $x$, $\tan x$, where $x$ is <code>self</code>.</p>
<p>The domain and range of this function are both $(-\infin, \infin)$.</p>
<h1 id="examples-44" class="section-header"><a href="#examples-44">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> (<span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">/</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>)).<span class="ident">tan</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.atan2" class="method"><code>pub fn <a href="#method.atan2" class="fnname">atan2</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trig.rs.html#239-277" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the 2-argument inverse tangent of $x$ and $y$, $\arctan(y, x)$, where $x$
is the argument and $y$ is <code>self</code>.</p>
<p>The single-argument <a href="#method.atan"><code>atan</code></a> function always returns values in either the first (0
to $\pi$/2) or fourth (0 to $-\pi$/2) quadrants. However, first-quadrant results
repeat themselves in the third quadrant, and fourth-quadrant results repeat
themselves in the second. For example, $\tan \frac{\pi}{4}$ is 1, but so is $\tan
\frac{3\pi}{4}$. Single-argument <a href="#method.atan"><code>atan</code></a> cannot distinguish between these two
possibilities, so it always returns the one in the range $[-\frac{\pi}{2},
\frac{\pi}{2}]$.</p>
<p>The double-argument <code>atan2</code> can return either, depending on the arguments. It
essentially returns the angle between the positive x-axis and the point $(x, y)$,
where $y$ is <code>self</code> and $x$ is the argument. Therefore <code>dd!(1).atan2(dd!(1))</code>
returns $\frac{\pi}{4}$ (first quadrant), but flipping both signs to
<code>dd!(-1).atan2(dd!(-1))</code> gives the $-\frac{3\pi}{4}$ result (third quadrant).</p>
<p>This function extends the range of the result to $[-\pi, \pi]$.</p>
<p>Because this function deals with angles around the origin and Cartesian coordinates,
it's very useful for converting between Cartesian and polar coordinates.</p>
<h1 id="examples-45" class="section-header"><a href="#examples-45">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">pi</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>;

<span class="comment">// -π/4 radians (45 degrees clockwise)</span>
<span class="kw">let</span> <span class="ident">x1</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>);
<span class="kw">let</span> <span class="ident">y1</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3</span>);
<span class="kw">let</span> <span class="ident">expected1</span> <span class="op">=</span> <span class="op">-</span><span class="ident">Double</span>::<span class="ident">FRAC_PI_4</span>;

<span class="comment">// 3π/4 radians (135 degrees counter-clockwise)</span>
<span class="kw">let</span> <span class="ident">x2</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">3</span>);
<span class="kw">let</span> <span class="ident">y2</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>);
<span class="kw">let</span> <span class="ident">expected2</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">FRAC_3_PI_4</span>;

<span class="kw">let</span> <span class="ident">diff1</span> <span class="op">=</span> (<span class="ident">y1</span>.<span class="ident">atan2</span>(<span class="ident">x1</span>) <span class="op">-</span> <span class="ident">expected1</span>).<span class="ident">abs</span>();
<span class="kw">let</span> <span class="ident">diff2</span> <span class="op">=</span> (<span class="ident">y2</span>.<span class="ident">atan2</span>(<span class="ident">x2</span>) <span class="op">-</span> <span class="ident">expected2</span>).<span class="ident">abs</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff1</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff2</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.asin" class="method"><code>pub fn <a href="#method.asin" class="fnname">asin</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trig.rs.html#295-300" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the inverse sine of $x$, $\sin^{-1} x$, where $x$ is <code>self</code>.</p>
<p>The domain of this function is $[-1, 1]$ while the range is $[-\frac{\pi}{2},
\frac{\pi}{2}]$. Arguments outside of this domain will result in <a href="#associatedconstant.NAN"><code>NAN</code></a>.</p>
<h1 id="examples-46" class="section-header"><a href="#examples-46">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>).<span class="ident">asin</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">/</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>);  <span class="comment">// π/2</span>

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.acos" class="method"><code>pub fn <a href="#method.acos" class="fnname">acos</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trig.rs.html#318-323" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the inverse cosine of $x$, $\cos^{-1} x$, where $x$ is <code>self</code>.</p>
<p>The domain of this function is $[-1, 1]$ and the range is $[0, \pi]$. Arguments
outside of the domain will result in <a href="#associatedconstant.NAN"><code>NAN</code></a>.</p>
<h1 id="examples-47" class="section-header"><a href="#examples-47">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>).<span class="ident">acos</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">0</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div><h4 id="method.atan" class="method"><code>pub fn <a href="#method.atan" class="fnname">atan</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/trig.rs.html#346-348" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the inverse tangent of $x$, $\tan^{-1} x$, where $x$ is <code>self</code>.</p>
<p>This is the single-argument version of this function (<a href="#method.atan2"><code>atan2</code></a> is the two-argument
inverse tangent). Though inverse tangents have multiple answers, this function will
always return the one with the lowest absolute value. <code>x.atan()</code> is the same as
<code>x.atan2(Double::ONE)</code>.</p>
<p>The domain of this function is $(-\infin, \infin)$ and the range is
$[-\frac{\pi}{2}, \frac{\pi}{2}]$.</p>
<h1 id="examples-48" class="section-header"><a href="#examples-48">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>).<span class="ident">atan</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">/</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>);  <span class="comment">// π/4</span>

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-7" class="impl"><code class="in-band">impl <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-7" class="anchor"></a><a class="srclink" href="../src/qd/double.rs.html#100-122" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.new" class="method"><code>pub const fn <a href="#method.new" class="fnname">new</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a>, b: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double.rs.html#119-121" title="goto source code">[src]</a></h4><div class="docblock"><p>Creates a <code>Double</code> with the two arguments as the internal components.</p>
<p><strong>Be sure you know what you're doing if you use this function.</strong> It does not
normalize its components, meaning that if they aren't already normalized by the
caller, this number will not work the way one would expect (it'll fail equality
tests that it should pass, it may be classified incorrectly, etc.).</p>
<p>This function is primarily for creating constants where the normalization is
obviously unnecessary. For example, if a <code>Double</code> version of the number <code>10</code> is
needed, <code>Double::new(10.0, 0.0)</code> is a good way to do it in order to save the cost
of the normalization that is obviously not needed.</p>
<h1 id="examples-49" class="section-header"><a href="#examples-49">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">d</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">new</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">d</span>.<span class="ident">is_zero</span>());</pre></div>
</div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><h3 id="impl-Add%3C%26%27_%20Double%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Add%3C%26%27_%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/add.rs.html#43-64" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-13" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>+</code> operator.</p>
</div><h4 id="method.add-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add" class="fnname">add</a>(self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/add.rs.html#61-63" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x + y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>+</code> operator between two references to <code>Double</code>s.</p>
<h1 id="examples-81" class="section-header"><a href="#examples-81">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span> <span class="op">+</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;5.859874482048838473822930854632&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Add%3C%26%27_%20Double%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Add%3C%26%27_%20Double%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/add.rs.html#66-87" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-14" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>+</code> operator.</p>
</div><h4 id="method.add-2" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add" class="fnname">add</a>(self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/add.rs.html#84-86" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x + y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>+</code> operator between a <code>Double</code> and a reference to a <code>Double</code>.</p>
<h1 id="examples-82" class="section-header"><a href="#examples-82">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span> <span class="op">+</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;5.859874482048838473822930854632&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Add%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Add%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/add.rs.html#12-41" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-12" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>+</code> operator.</p>
</div><h4 id="method.add" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add" class="fnname">add</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/add.rs.html#29-40" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x + y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>+</code> operator between two <code>Double</code>s.</p>
<h1 id="examples-80" class="section-header"><a href="#examples-80">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span> <span class="op">+</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;5.859874482048838473822930854632&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Add%3CDouble%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Add%3CDouble%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/add.rs.html#89-110" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-15" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>+</code> operator.</p>
</div><h4 id="method.add-3" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add" class="fnname">add</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/add.rs.html#107-109" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x + y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>+</code> operator between a refernce to a <code>Double</code> and a <code>Double</code>.</p>
<h1 id="examples-83" class="section-header"><a href="#examples-83">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span> <span class="op">+</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;5.859874482048838473822930854632&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-AddAssign%3C%26%27_%20Double%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-AddAssign%3C%26%27_%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/add.rs.html#136-158" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.add_assign-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fnname">add_assign</a>(&amp;mut self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>)</code><a class="srclink" href="../src/qd/double/add.rs.html#153-157" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x + y$, where $x$ is <code>self</code> and $y$ is the argument, assigning the result
to <code>self</code>.</p>
<p>This implements the <code>+=</code> operator between a <code>Double</code> and a reference to a <code>Double</code>.</p>
<h1 id="examples-91" class="section-header"><a href="#examples-91">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="ident">x</span> <span class="op">+</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;5.859874482048838473822930854632&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-AddAssign%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-AddAssign%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/add.rs.html#112-134" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.add_assign" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fnname">add_assign</a>(&amp;mut self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>)</code><a class="srclink" href="../src/qd/double/add.rs.html#129-133" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x + y$, where $x$ is <code>self</code> and $y$ is the argument, assigning the result
to <code>self</code>.</p>
<p>This implements the <code>+=</code> operator between two <code>Double</code>s.</p>
<h1 id="examples-90" class="section-header"><a href="#examples-90">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="ident">x</span> <span class="op">+</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;5.859874482048838473822930854632&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Clone" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Clone" class="anchor"></a><a class="srclink" href="../src/qd/double.rs.html#97" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.clone" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double.rs.html#97" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id="method.clone_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#128-130" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id="impl-Copy" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Copy" class="anchor"></a><a class="srclink" href="../src/qd/double.rs.html#97" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Debug" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Debug" class="anchor"></a><a class="srclink" href="../src/qd/double/display.rs.html#163-186" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../src/qd/double/display.rs.html#167-185" title="goto source code">[src]</a></h4><div class="docblock"><p>Formats a <code>Double</code> for display when the &quot;<code>?</code>&quot; formatting option is specified.</p>
<p>See <a href="#method.fmt-1"><code>Display::fmt</code></a> for more information.</p>
</div></div><h3 id="impl-Default" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Default" class="anchor"></a><a class="srclink" href="../src/qd/double.rs.html#97" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.default" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double.rs.html#97" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 id="impl-Display" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Display" class="anchor"></a><a class="srclink" href="../src/qd/double/display.rs.html#14-95" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../src/qd/double/display.rs.html#78-94" title="goto source code">[src]</a></h4><div class="docblock"><p>Formats a <code>Double</code> for display.</p>
<p>All formatting options that are shown in <a href="https://doc.rust-lang.org/std/fmt/index.html"><code>std::fmt</code></a> are supported <em>except</em> for
ones that are typically meant only for integers (hexadecimal, binary, octal, and
pointer formats). Because of this, the &quot;alternate&quot; (<code>#</code>) flag is only recognized
along with <code>?</code>, pretty-printing the <code>Debug</code> output.</p>
<p>By default, <code>Double</code>s are printed with 31 digits but drop trailing zeros.</p>
<p>This function also provides the formatting for <a href="#tymethod.to_string"><code>to_string</code></a>, which renders the
<code>Double</code> as if formatted with an empty format specifier (<code>&quot;{}&quot;</code>).</p>
<h1 id="examples-67" class="section-header"><a href="#examples-67">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1.5</span>)) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;1.5&quot;</span>);

<span class="comment">// The next digit in π is 0, which is why it&#39;s one digit shorter than e</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">Double</span>::<span class="ident">PI</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;3.14159265358979323846264338328&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">Double</span>::<span class="ident">E</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;2.718281828459045235360287471353&quot;</span>);

<span class="comment">// to_string renders as if formatted with &quot;{}&quot;</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">PI</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;3.14159265358979323846264338328&quot;</span>);

<span class="comment">// debug</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">Double</span>::<span class="ident">PI</span>) <span class="op">=</span><span class="op">=</span>
    <span class="string">&quot;Double(3.141592653589793e0, 1.2246467991473532e-16)&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:#?}&quot;</span>, <span class="ident">Double</span>::<span class="ident">PI</span>) <span class="op">=</span><span class="op">=</span>
<span class="string">&quot;Double(
    3.141592653589793e0,
    1.2246467991473532e-16
)&quot;</span>);

<span class="comment">// precision and exponents</span>
<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">0.016_777_216</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:.0}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;0&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:.5}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;0.01678&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:.12}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;0.016777216000&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:.3e}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;1.678e-2&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:.*e}&quot;</span>, <span class="number">3</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;1.678e-2&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{0:.1$E}&quot;</span>, <span class="ident">value</span>, <span class="number">4</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;1.6777E-2&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:.prec$E}&quot;</span>, <span class="ident">value</span>, <span class="ident">prec</span> <span class="op">=</span> <span class="number">10</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;1.6777216000E-2&quot;</span>);

<span class="comment">// width, alignment, and fill</span>
<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">123_456</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:10}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;    123456&quot;</span>); <span class="comment">// right-align is the default</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:&gt;10}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;    123456&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:&lt;10}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;123456    &quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:^10}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;  123456  &quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0&gt;10}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;0000123456&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:*&lt;10}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;123456****&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:&#39;^10}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;&#39;&#39;123456&#39;&#39;&quot;</span>);

<span class="comment">// plus sign and sign-aware zero fill</span>
<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">123_456</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:+}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;+123456&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0&gt;10}&quot;</span>, <span class="op">-</span><span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;000-123456&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:010}&quot;</span>, <span class="op">-</span><span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;-000123456&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:+012e}&quot;</span>, <span class="ident">value</span>) <span class="op">=</span><span class="op">=</span> <span class="string">&quot;+001.23456e5&quot;</span>);</pre></div>
</div></div><h3 id="impl-Div%3C%26%27_%20Double%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html" title="trait core::ops::arith::Div">Div</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Div%3C%26%27_%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/div.rs.html#58-78" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>/</code> operator.</p>
</div><h4 id="method.div-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html#tymethod.div" class="fnname">div</a>(self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/div.rs.html#75-77" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \div y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>/</code> operator between two references to <code>Double</code>s.</p>
<h1 id="examples-69" class="section-header"><a href="#examples-69">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span> <span class="op">/</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.8652559794322650872177747896461&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Div%3C%26%27_%20Double%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html" title="trait core::ops::arith::Div">Div</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Div%3C%26%27_%20Double%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/div.rs.html#80-101" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-2" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>/</code> operator.</p>
</div><h4 id="method.div-2" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html#tymethod.div" class="fnname">div</a>(self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/div.rs.html#98-100" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \div y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>/</code> operator between a <code>Double</code> and a reference to a <code>Double</code>.</p>
<h1 id="examples-70" class="section-header"><a href="#examples-70">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span> <span class="op">/</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.8652559794322650872177747896461&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Div%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html" title="trait core::ops::arith::Div">Div</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Div%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/div.rs.html#22-56" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>/</code> operator.</p>
</div><h4 id="method.div" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html#tymethod.div" class="fnname">div</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/div.rs.html#39-55" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \div y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>/</code> operator between two <code>Double</code>s.</p>
<h1 id="examples-68" class="section-header"><a href="#examples-68">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span> <span class="op">/</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.8652559794322650872177747896461&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Div%3CDouble%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html" title="trait core::ops::arith::Div">Div</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Div%3CDouble%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/div.rs.html#103-124" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-3" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>/</code> operator.</p>
</div><h4 id="method.div-3" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Div.html#tymethod.div" class="fnname">div</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/div.rs.html#121-123" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \div y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>/</code> operator between a reference to a <code>Double</code> and a <code>Double</code>.</p>
<h1 id="examples-71" class="section-header"><a href="#examples-71">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span> <span class="op">/</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.8652559794322650872177747896461&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-DivAssign%3C%26%27_%20Double%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.DivAssign.html" title="trait core::ops::arith::DivAssign">DivAssign</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-DivAssign%3C%26%27_%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/div.rs.html#150-172" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.div_assign-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.DivAssign.html#tymethod.div_assign" class="fnname">div_assign</a>(&amp;mut self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>)</code><a class="srclink" href="../src/qd/double/div.rs.html#167-171" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \div y$, where $x$ is <code>self</code> and $y$ is the argument, assigning the
result to <code>self</code>.</p>
<p>This implements the <code>/=</code> operator between a <code>Double</code> and a reference to a <code>Double</code>.</p>
<h1 id="examples-97" class="section-header"><a href="#examples-97">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="ident">x</span> <span class="op">/</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.8652559794322650872177747896461&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-DivAssign%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.DivAssign.html" title="trait core::ops::arith::DivAssign">DivAssign</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-DivAssign%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/div.rs.html#126-148" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.div_assign" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.DivAssign.html#tymethod.div_assign" class="fnname">div_assign</a>(&amp;mut self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>)</code><a class="srclink" href="../src/qd/double/div.rs.html#143-147" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \div y$, where $x$ is <code>self</code> and $y$ is the argument, assigning the
result to <code>self</code>.</p>
<p>This implements the <code>/=</code> operator between two <code>Double</code>s.</p>
<h1 id="examples-96" class="section-header"><a href="#examples-96">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="ident">x</span> <span class="op">/</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.8652559794322650872177747896461&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-From%3C%26%27_%20str%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'_ <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3C%26%27_%20str%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#292-321" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-11" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#318-320" title="goto source code">[src]</a></h4><div class="docblock"><p>Parses a string to create a <code>Double</code>.</p>
<p>The parser works pretty similarly to parsers for <code>f32</code> and <code>f64</code>. It will fail if
characters are present that are not digits, decimal points, signs, or exponent
markers. It will also fail if there are multiples of these or if they're in the
wrong places; two decimal points or a negative sign after the number will both be
rejected, for instance.</p>
<p>Failure will return <a href="#associatedconstant.NAN"><code>NAN</code></a>. This can be an issue because parsing the string <code>&quot;nan&quot;</code>
<em>also</em> produces <a href="#associatedconstant.NAN"><code>NAN</code></a>. For this reason it's suggested to use <a href="#method.from_str"><code>from_str</code></a> (or its
associated <code>parse</code> function) instead of this function if there is any chance that
the parsed string will be legitimately <a href="#associatedconstant.NAN"><code>NAN</code></a>.</p>
<h1 id="examples-61" class="section-header"><a href="#examples-61">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> (<span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>).<span class="ident">powi</span>(<span class="number">15</span>) <span class="op">-</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>)) <span class="op">/</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>).<span class="ident">powi</span>(<span class="number">15</span>);
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="string">&quot;0.9999999303082806237436760862691&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-From%3C(f64%2C%20f64)%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3C(f64%2C%20f64)%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#265-290" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-10" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>((a, b): <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#287-289" title="goto source code">[src]</a></h4><div class="docblock"><p>Generates a <code>Double</code> from a 2-tuple of <code>f64</code>s.</p>
<p>This conversion acts like <a href="#method.new"><code>new</code></a> does: it assumes that if you're creating a
<code>Double</code> out of a pair of numbers, you already know what you want those numbers to
be. Therefore it neither renormalizes or accounts for rounding error.</p>
<p>No other <code>From</code> implementations are provided for tuples. There is no way to provide
a pre-normalized pair of integers, and since tuple conversion doesn't adjust for
rounding error, it's better to make the user explicity cast <code>f32</code>s first in the
manner of their choosing.</p>
<h1 id="examples-60" class="section-header"><a href="#examples-60">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// These are the components used to define Double::PI</span>
<span class="kw">let</span> <span class="ident">d</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>((<span class="number">3.141592653589793e0</span>, <span class="number">1.2246467991473532e-16</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">d</span> <span class="op">=</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>);</pre></div>
</div></div><h3 id="impl-From%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a></code><a href="#impl-From%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#323-347" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-12" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a></code><a class="srclink" href="../src/qd/double/from.rs.html#344-346" title="goto source code">[src]</a></h4><div class="docblock"><p>Converts a <code>Double</code> into an <code>f64</code>.</p>
<p>This will lose precision if the second component of the <code>Double</code> is not 0, but it
will not lose range.</p>
<p>No other conversions from <code>Double</code> to numeric types are provided, as every other one
has the capability of losing range (for example, no other type could be used to
represent <code>dd!(1e308)</code>). Casts can be made from the <code>f64</code> provided by this function
to other numeric types as needed.</p>
<h1 id="examples-62" class="section-header"><a href="#examples-62">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">f64</span>::<span class="ident">from</span>(<span class="ident">a</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">std</span>::<span class="ident">f64</span>::<span class="ident">consts</span>::<span class="ident">PI</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="number">1e-15</span>);</pre></div>
</div></div><h3 id="impl-From%3CDouble%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a></code><a href="#impl-From%3CDouble%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#349-369" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-13" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a></code><a class="srclink" href="../src/qd/double/from.rs.html#366-368" title="goto source code">[src]</a></h4><div class="docblock"><p>Converts a <code>Double</code> into a tuple of <code>f64</code>s.</p>
<p>The components of the double become the components of the returned tuple. Note that,
while the value of the first component is simply the <code>f64</code> cast of the <code>Double</code>
itself, the second component encodes the next digits of the <code>Double</code> <em>plus</em> the
rounding error in the first component. For that reason, it's not likely to be very
useful outside of a <code>Double</code> context.</p>
<h1 id="examples-63" class="section-header"><a href="#examples-63">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> (<span class="ident">a</span>, <span class="ident">b</span>) <span class="op">=</span> <span class="op">&lt;</span>(<span class="ident">f64</span>, <span class="ident">f64</span>)<span class="op">&gt;</span>::<span class="ident">from</span>(<span class="ident">Double</span>::<span class="ident">PI</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span> <span class="op">=</span><span class="op">=</span> <span class="number">3.141592653589793e0</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b</span> <span class="op">=</span><span class="op">=</span> <span class="number">1.2246467991473532e-16</span>); <span class="comment">// *not* the next 16 digits of π</span></pre></div>
</div></div><h3 id="impl-From%3CDouble%3E-2" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Quad.html" title="struct qd::Quad">Quad</a></code><a href="#impl-From%3CDouble%3E-2" class="anchor"></a><a class="srclink" href="../src/qd/quad/from.rs.html#431-451" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-14" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Quad.html" title="struct qd::Quad">Quad</a></code><a class="srclink" href="../src/qd/quad/from.rs.html#448-450" title="goto source code">[src]</a></h4><div class="docblock"><p>Generates a <code>Quad</code> from a <code>Double</code>.</p>
<p>The new <code>Quad</code>'s third and fourth components will be used to account for
floating-point rounding error at the end of the <code>Double</code>, but it will of course
otherwise only have the precision of the <code>Double</code> used to make it.</p>
<h1 id="examples-64" class="section-header"><a href="#examples-64">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="ident">Quad</span>::<span class="ident">from</span>(<span class="string">&quot;0.9999999303082806237436760862691&quot;</span>);
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> (<span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>).<span class="ident">powi</span>(<span class="number">15</span>) <span class="op">-</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>)) <span class="op">/</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>).<span class="ident">powi</span>(<span class="number">15</span>);
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Quad</span>::<span class="ident">from</span>(<span class="ident">a</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">qd</span><span class="macro">!</span>(<span class="number">1e-60</span>));</pre></div>
</div></div><h3 id="impl-From%3Cf32%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f32.html">f32</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3Cf32%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#210-263" title="goto source code">[src]</a></h3><div class="docblock"><p>Generates a <code>Double</code> from an <code>f32</code>.</p>
<p>This function <em>does</em> account for floating point rounding error. Even though the
first component of a <code>Double</code> is enough to fit an <code>f32</code>, if that <code>f32</code> is not
exactly representable in binary, then the second component of the <code>Double</code> will
account for the rounding error.</p>
<p>Note that in order to do this, the <code>f32</code> needs to be parsed digit by digit. While
the parser does work quite fast with integers or any <code>f32</code> that is represented
perfectly in binary (any number that can be represented as a fraction with a power
of 2 in the denominator), it's not a particularly fast operation otherwise.</p>
<h1 id="examples-58" class="section-header"><a href="#examples-58">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Exactly representable in binary</span>
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">0.9921875f32</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;0.9921875&quot;</span>);

<span class="comment">// Xot exactly representable in binary</span>
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">0.9921876f32</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;0.9921876&quot;</span>);</pre></div>
</div><div class="impl-items"><h4 id="method.from-8" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f32.html">f32</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#210-263" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-From%3Cf64%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3Cf64%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#210-263" title="goto source code">[src]</a></h3><div class="docblock"><p>Generates a <code>Double</code> from an <code>f64</code>.</p>
<p>This function <em>does</em> account for floating point rounding error. Even though the
first component of a <code>Double</code> is enough to fit an <code>f64</code>, if that <code>f64</code> is not
exactly representable in binary, then the second component of the <code>Double</code> will
account for the rounding error.</p>
<p>Note that in order to do this, the <code>f64</code> needs to be parsed digit by digit. While
the parser does work quite fast with integers or any <code>f64</code> that is represented
perfectly in binary (any number that can be represented as a fraction with a power
of 2 in the denominator), it's not a particularly fast operation otherwise.</p>
<h1 id="examples-59" class="section-header"><a href="#examples-59">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Exactly representable in binary</span>
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">0.999969482421875f64</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;0.999969482421875&quot;</span>);

<span class="comment">// Not exactly representable in binary</span>
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">0.999969482421876f64</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;0.999969482421876&quot;</span>);</pre></div>
</div><div class="impl-items"><h4 id="method.from-9" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#210-263" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-From%3Ci16%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i16.html">i16</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3Ci16%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h3><div class="docblock"><p>Generates a <code>Double</code> from an <code>i16</code>.</p>
<h1 id="examples-52" class="section-header"><a href="#examples-52">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="op">-</span><span class="number">32768i16</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;-32768&quot;</span>);</pre></div>
</div><div class="impl-items"><h4 id="method.from-2" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i16.html">i16</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-From%3Ci32%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3Ci32%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h3><div class="docblock"><p>Generates a <code>Double</code> from an <code>i32</code>.</p>
<h1 id="examples-54" class="section-header"><a href="#examples-54">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="op">-</span><span class="number">2_147_483_648i32</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;-2147483648&quot;</span>);</pre></div>
</div><div class="impl-items"><h4 id="method.from-4" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-From%3Ci64%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3Ci64%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#147-160" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-7" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#157-159" title="goto source code">[src]</a></h4><div class="docblock"><p>Generates a <code>Double</code> from an <code>i64</code>.</p>
<h1 id="examples-57" class="section-header"><a href="#examples-57">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="op">-</span><span class="number">9_223_372_036_854_775_808i64</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;-9223372036854775808&quot;</span>);</pre></div>
</div></div><h3 id="impl-From%3Ci8%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3Ci8%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h3><div class="docblock"><p>Generates a <code>Double</code> from an <code>i8</code>.</p>
<h1 id="examples-50" class="section-header"><a href="#examples-50">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="op">-</span><span class="number">128i8</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;-128&quot;</span>);</pre></div>
</div><div class="impl-items"><h4 id="method.from" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-From%3Cu16%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3Cu16%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h3><div class="docblock"><p>Generates a <code>Double</code> from a <code>u8</code>.</p>
<h1 id="examples-53" class="section-header"><a href="#examples-53">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">65535u16</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;65535&quot;</span>);</pre></div>
</div><div class="impl-items"><h4 id="method.from-3" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-From%3Cu32%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3Cu32%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h3><div class="docblock"><p>Generates a <code>Double</code> from a <code>u32</code>.</p>
<h1 id="examples-55" class="section-header"><a href="#examples-55">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">4_294_967_295u32</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;4294967295&quot;</span>);</pre></div>
</div><div class="impl-items"><h4 id="method.from-5" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-From%3Cu64%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3Cu64%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#132-145" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-6" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#142-144" title="goto source code">[src]</a></h4><div class="docblock"><p>Generates a <code>Double</code> from a <code>u64</code>.</p>
<h1 id="examples-56" class="section-header"><a href="#examples-56">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">18_446_744_073_709_551_615u64</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;18446744073709551615&quot;</span>);</pre></div>
</div></div><h3 id="impl-From%3Cu8%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-From%3Cu8%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h3><div class="docblock"><p>Generates a <code>Double</code> from a <code>u8</code>.</p>
<h1 id="examples-51" class="section-header"><a href="#examples-51">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">255u8</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from</span>(<span class="ident">x</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">=</span><span class="op">=</span> <span class="string">&quot;255&quot;</span>);</pre></div>
</div><div class="impl-items"><h4 id="method.from-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/from.rs.html#66-127" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-FromStr" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-FromStr" class="anchor"></a><a class="srclink" href="../src/qd/double/from_str.rs.html#12-139" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Err" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#associatedtype.Err" class="type">Err</a> = <a class="struct" href="../qd/error/struct.ParseDoubleError.html" title="struct qd::error::ParseDoubleError">ParseDoubleError</a></code></h4><div class='docblock'><p>The associated error which can be returned from parsing.</p>
</div><h4 id="method.from_str" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fnname">from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>, <a class="struct" href="../qd/error/struct.ParseDoubleError.html" title="struct qd::error::ParseDoubleError">ParseDoubleError</a>&gt;</code><a class="srclink" href="../src/qd/double/from_str.rs.html#47-138" title="goto source code">[src]</a></h4><div class="docblock"><p>Parses a string to create a <code>Double</code>.</p>
<p>The parser works pretty similarly to parsers for <code>f32</code> and <code>f64</code>. It will fail if
characters are present that are not digits, decimal points, signs, or exponent
markers. It will also fail if there are multiples of these or if they're in the
wrong places; two decimal points or a negative sign after the number will both be
rejected, for instance.</p>
<p>Failure will return a <a href="error/struct.ParseDoubleError.html"><code>ParseDoubleError</code></a> of some kind.</p>
<h1 id="examples-101" class="section-header"><a href="#examples-101">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>::<span class="ident">FromStr</span>;

<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> (<span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>).<span class="ident">powi</span>(<span class="number">15</span>) <span class="op">-</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>)) <span class="op">/</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>).<span class="ident">powi</span>(<span class="number">15</span>);

<span class="kw">let</span> <span class="ident">x1</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">from_str</span>(<span class="string">&quot;0.9999999303082806237436760862691&quot;</span>).<span class="ident">unwrap</span>();
<span class="comment">// `parse` calls `from_str` in the background, so this is equivalent. In fact it&#39;s</span>
<span class="comment">// probably preferred because it doesn&#39;t require importing `FromStr`. The turbofish</span>
<span class="comment">// (or type annotation on x2, if you prefer) is required instead if the type can&#39;t</span>
<span class="comment">// otherwise be inferred.</span>
<span class="kw">let</span> <span class="ident">x2</span> <span class="op">=</span> <span class="string">&quot;0.9999999303082806237436760862691&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">Double</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">diff1</span> <span class="op">=</span> (<span class="ident">x1</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff1</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="ident">diff2</span> <span class="op">=</span> (<span class="ident">x2</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff2</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Index%3Cusize%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Index%3Cusize%3E" class="anchor"></a><a class="srclink" href="../src/qd/double.rs.html#124-158" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-22" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a></code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id="method.index" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, idx: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a></code><a class="srclink" href="../src/qd/double.rs.html#148-157" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns one of the components of the <code>Double</code>.</p>
<p>Using index <code>0</code> will return the first component and using index <code>1</code> will return the
second.</p>
<p>One capability that is <em>not</em> provided is mutable indexing; ensuring that a <code>Double</code>
is normalized would be impossible if they could be individually changed at will.
<code>Double</code>s are immutable like any other number; if you need a new value for a
<code>Double</code>, you should simply create a new <code>Double</code>.</p>
<p>This is primarily provided for making certain mathematical algorithms easier to
implement. There isn't a lot meaning to an individual component of a <code>Double</code> other
than the first.</p>
<h1 id="examples-100" class="section-header"><a href="#examples-100">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">d</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">ONE</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">d</span>[<span class="number">0</span>] <span class="op">=</span><span class="op">=</span> <span class="number">1.0</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">d</span>[<span class="number">1</span>] <span class="op">=</span><span class="op">=</span> <span class="number">0.0</span>);</pre></div>
</div></div><h3 id="impl-LowerExp" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerExp.html" title="trait core::fmt::LowerExp">LowerExp</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-LowerExp" class="anchor"></a><a class="srclink" href="../src/qd/double/display.rs.html#97-128" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt-2" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerExp.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../src/qd/double/display.rs.html#101-127" title="goto source code">[src]</a></h4><div class="docblock"><p>Formats a <code>Double</code> for display when the &quot;<code>e</code>&quot; formatting option is specified.</p>
<p>See <a href="#method.fmt-1"><code>Display::fmt</code></a> for more information.</p>
</div></div><h3 id="impl-Mul%3C%26%27_%20Double%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html" title="trait core::ops::arith::Mul">Mul</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Mul%3C%26%27_%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/mul.rs.html#41-62" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-17" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>*</code> operator.</p>
</div><h4 id="method.mul-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html#tymethod.mul" class="fnname">mul</a>(self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/mul.rs.html#59-61" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \times y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>*</code> operator between two references to <code>Double</code>s.</p>
<h1 id="examples-85" class="section-header"><a href="#examples-85">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span> <span class="op">*</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;8.539734222673567065463550869547&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Mul%3C%26%27_%20Double%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html" title="trait core::ops::arith::Mul">Mul</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Mul%3C%26%27_%20Double%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/mul.rs.html#64-85" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-18" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>*</code> operator.</p>
</div><h4 id="method.mul-2" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html#tymethod.mul" class="fnname">mul</a>(self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/mul.rs.html#82-84" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \times y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>*</code> operator between a <code>Double</code> and a reference to a <code>Double</code>.</p>
<h1 id="examples-86" class="section-header"><a href="#examples-86">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span> <span class="op">*</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;8.539734222673567065463550869547&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Mul%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html" title="trait core::ops::arith::Mul">Mul</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Mul%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/mul.rs.html#12-39" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-16" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>*</code> operator.</p>
</div><h4 id="method.mul" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html#tymethod.mul" class="fnname">mul</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/mul.rs.html#29-38" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \times y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>*</code> operator between two <code>Double</code>s.</p>
<h1 id="examples-84" class="section-header"><a href="#examples-84">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span> <span class="op">*</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;8.539734222673567065463550869547&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Mul%3CDouble%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html" title="trait core::ops::arith::Mul">Mul</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Mul%3CDouble%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/mul.rs.html#87-108" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-19" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>*</code> operator.</p>
</div><h4 id="method.mul-3" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Mul.html#tymethod.mul" class="fnname">mul</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/mul.rs.html#105-107" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \times y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the <code>*</code> operator between a reference to a <code>Double</code> and a <code>Double</code>.</p>
<h1 id="examples-87" class="section-header"><a href="#examples-87">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span> <span class="op">*</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;8.539734222673567065463550869547&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-MulAssign%3C%26%27_%20Double%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.MulAssign.html" title="trait core::ops::arith::MulAssign">MulAssign</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-MulAssign%3C%26%27_%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/mul.rs.html#134-156" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.mul_assign-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.MulAssign.html#tymethod.mul_assign" class="fnname">mul_assign</a>(&amp;mut self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>)</code><a class="srclink" href="../src/qd/double/mul.rs.html#151-155" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \times y$, where $x$ is <code>self</code> and $y$ is the argument, assigning the
result to <code>self</code>.</p>
<p>This implements the <code>*=</code> operator between a <code>Double</code> and a reference to a <code>Double</code>.</p>
<h1 id="examples-95" class="section-header"><a href="#examples-95">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="ident">x</span> <span class="kw-2">*</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;8.539734222673567065463550869547&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-MulAssign%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.MulAssign.html" title="trait core::ops::arith::MulAssign">MulAssign</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-MulAssign%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/mul.rs.html#110-132" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.mul_assign" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.MulAssign.html#tymethod.mul_assign" class="fnname">mul_assign</a>(&amp;mut self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>)</code><a class="srclink" href="../src/qd/double/mul.rs.html#127-131" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x \times y$, where $x$ is <code>self</code> and $y$ is the argument, assigning the
result to <code>self</code>.</p>
<p>This implements the <code>*=</code> operator between two <code>Double</code>s.</p>
<h1 id="examples-94" class="section-header"><a href="#examples-94">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="ident">x</span> <span class="kw-2">*</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;8.539734222673567065463550869547&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Neg" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Neg.html" title="trait core::ops::arith::Neg">Neg</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Neg" class="anchor"></a><a class="srclink" href="../src/qd/double/neg.rs.html#9-29" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-20" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Neg.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>-</code> operator.</p>
</div><h4 id="method.neg" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Neg.html#tymethod.neg" class="fnname">neg</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/neg.rs.html#26-28" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $-x$, where $x$ is <code>self</code>, producing a new <code>Double</code> as the result.</p>
<p>This implements the unary <code>-</code> operator for <code>Double</code>s.</p>
<h1 id="examples-88" class="section-header"><a href="#examples-88">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="op">-</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-3.1415926535897932384626433832795&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Neg-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Neg.html" title="trait core::ops::arith::Neg">Neg</a> for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Neg-1" class="anchor"></a><a class="srclink" href="../src/qd/double/neg.rs.html#31-51" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-21" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Neg.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>-</code> operator.</p>
</div><h4 id="method.neg-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Neg.html#tymethod.neg" class="fnname">neg</a>(self) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/neg.rs.html#48-50" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $-x$, where $x$ is <code>self</code>, producing a new <code>Double</code> as the result.</p>
<p>This implements the unary <code>-</code> operator for references to <code>Double</code>s.</p>
<h1 id="examples-89" class="section-header"><a href="#examples-89">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="op">-</span><span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-3.1415926535897932384626433832795&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">x</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-PartialEq%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-PartialEq%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/comp.rs.html#14-37" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.eq" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/qd/double/comp.rs.html#34-36" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates whether <code>self</code> and the argument are equal to one another.</p>
<p>This implements the <code>==</code> and <code>!=</code> operators between <code>Double</code>s.</p>
<p>Equality works exactly the same as it does for system floating-point numbers (<code>f64</code>,
etc.), including zero equalling negative zero, <code>NaN</code> equalling nothing (including
itself), etc. Notably, equality should be used with care since floating-point
rounding, even with the increased precision of <code>Double</code>s, will still cause some
numbers that should be equal to not be equal.</p>
<h1 id="examples-65" class="section-header"><a href="#examples-65">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">=</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">E</span> <span class="op">!</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="number">0.0</span>) <span class="op">=</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">0.0</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">NAN</span> <span class="op">!</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">NAN</span>);</pre></div>
</div><h4 id="method.ne" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#209-211" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id="impl-PartialOrd%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-PartialOrd%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/comp.rs.html#39-64" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.partial_cmp" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../src/qd/double/comp.rs.html#58-63" title="goto source code">[src]</a></h4><div class="docblock"><p>Calculates how <code>self</code> and the argument should be ordered.</p>
<p>This implements the <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators between two <code>Double</code>s.</p>
<p>Ordering works the same as it does for system floating-point numbers, including
<a href="#associatedconstant.NAN"><code>NAN</code></a> returning false for any of these operators (including when comparing it to
itself).</p>
<h1 id="examples-66" class="section-header"><a href="#examples-66">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">&gt;</span> <span class="ident">Double</span>::<span class="ident">E</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">dd</span><span class="macro">!</span>(<span class="number">0.0</span>) <span class="op">&lt;</span><span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="op">-</span><span class="number">0.0</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span>(<span class="ident">Double</span>::<span class="ident">NAN</span> <span class="op">&gt;</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">NAN</span>));</pre></div>
</div><h4 id="method.lt" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#959-961" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#978-980" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#996-998" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1015-1017" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-Product%3C%26%27a%20Double%3E" class="impl"><code class="in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/accum/trait.Product.html" title="trait core::iter::traits::accum::Product">Product</a>&lt;&amp;'a <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Product%3C%26%27a%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/iter.rs.html#74-92" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.product-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/accum/trait.Product.html#tymethod.product" class="fnname">product</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = &amp;'a <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt;,&nbsp;</span></code><a class="srclink" href="../src/qd/double/iter.rs.html#86-91" title="goto source code">[src]</a></h4><div class="docblock"><p>Multiples all of the referenced values in an iterator of <code>Double</code>s.</p>
<h1 id="examples-105" class="section-header"><a href="#examples-105">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">Product</span>;

<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">120</span>);
<span class="kw">let</span> <span class="ident">actual</span>: <span class="ident">Double</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">5</span>)].<span class="ident">iter</span>().<span class="ident">product</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">expected</span> <span class="op">=</span><span class="op">=</span> <span class="ident">actual</span>);</pre></div>
</div></div><h3 id="impl-Product%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/accum/trait.Product.html" title="trait core::iter::traits::accum::Product">Product</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Product%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/iter.rs.html#54-72" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.product" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/accum/trait.Product.html#tymethod.product" class="fnname">product</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt;,&nbsp;</span></code><a class="srclink" href="../src/qd/double/iter.rs.html#66-71" title="goto source code">[src]</a></h4><div class="docblock"><p>Multiplies all of the values in an iterator of <code>Double</code>s.</p>
<h1 id="examples-104" class="section-header"><a href="#examples-104">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">Product</span>;

<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">120</span>);
<span class="kw">let</span> <span class="ident">actual</span>: <span class="ident">Double</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">5</span>)].<span class="ident">into_iter</span>().<span class="ident">product</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">expected</span> <span class="op">=</span><span class="op">=</span> <span class="ident">actual</span>);</pre></div>
</div></div><h3 id="impl-Rem%3C%26%27_%20Double%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html" title="trait core::ops::arith::Rem">Rem</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Rem%3C%26%27_%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/rem.rs.html#47-83" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-5" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>%</code> operator.</p>
</div><h4 id="method.rem-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html#tymethod.rem" class="fnname">rem</a>(self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/rem.rs.html#80-82" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the remainder of $x \div y$, where $x$ is <code>self</code> and $y$ is the argument,
producing a new <code>Double</code> as the result.</p>
<p>The result is given the same sign as the dividend (<code>self</code>), no matter the sign of
the divisor. This is consistent with the way <code>f64</code> behaves.</p>
<p>This implements the <code>%</code> operator between two references to <code>Double</code>s.</p>
<h1 id="examples-73" class="section-header"><a href="#examples-73">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_x</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected_x</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_x</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="op">-</span><span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_y</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_y</span> <span class="op">=</span> (<span class="ident">y</span> <span class="op">-</span> <span class="ident">expected_y</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_y</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="ident">z</span> <span class="op">=</span> <span class="op">-</span><span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_z</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_z</span> <span class="op">=</span> (<span class="ident">z</span> <span class="op">-</span> <span class="ident">expected_z</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_z</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Rem%3C%26%27_%20Double%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html" title="trait core::ops::arith::Rem">Rem</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Rem%3C%26%27_%20Double%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/rem.rs.html#85-121" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-6" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>%</code> operator.</p>
</div><h4 id="method.rem-2" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html#tymethod.rem" class="fnname">rem</a>(self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/rem.rs.html#118-120" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the remainder of $x \div y$, where $x$ is <code>self</code> and $y$ is the argument,
producing a new <code>Double</code> as the result.</p>
<p>The result is given the same sign as the dividend (<code>self</code>), no matter the sign of
the divisor. This is consistent with the way <code>f64</code> behaves.</p>
<p>This implements the <code>%</code> operator between a <code>Double</code> and a reference to a <code>Double</code>.</p>
<h1 id="examples-74" class="section-header"><a href="#examples-74">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_x</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected_x</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_x</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="op">-</span><span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_y</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_y</span> <span class="op">=</span> (<span class="ident">y</span> <span class="op">-</span> <span class="ident">expected_y</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_y</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="ident">z</span> <span class="op">=</span> <span class="op">-</span><span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_z</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_z</span> <span class="op">=</span> (<span class="ident">z</span> <span class="op">-</span> <span class="ident">expected_z</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_z</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Rem%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html" title="trait core::ops::arith::Rem">Rem</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Rem%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/rem.rs.html#9-45" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-4" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>%</code> operator.</p>
</div><h4 id="method.rem" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html#tymethod.rem" class="fnname">rem</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/rem.rs.html#42-44" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the remainder of $x \div y$, where $x$ is <code>self</code> and $y$ is the argument,
producing a new <code>Double</code> as the result.</p>
<p>The result is given the same sign as the dividend (<code>self</code>), no matter the sign of
the divisor. This is consistent with the way <code>f64</code> behaves.</p>
<p>This implements the <code>%</code> operator between two <code>Double</code>s.</p>
<h1 id="examples-72" class="section-header"><a href="#examples-72">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_x</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected_x</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_x</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="op">-</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_y</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_y</span> <span class="op">=</span> (<span class="ident">y</span> <span class="op">-</span> <span class="ident">expected_y</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_y</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="ident">z</span> <span class="op">=</span> <span class="op">-</span><span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_z</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_z</span> <span class="op">=</span> (<span class="ident">z</span> <span class="op">-</span> <span class="ident">expected_z</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_z</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Rem%3CDouble%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html" title="trait core::ops::arith::Rem">Rem</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Rem%3CDouble%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/rem.rs.html#123-159" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-7" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>%</code> operator.</p>
</div><h4 id="method.rem-3" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Rem.html#tymethod.rem" class="fnname">rem</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/rem.rs.html#156-158" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the remainder of $x \div y$, where $x$ is <code>self</code> and $y$ is the argument,
producing a new <code>Double</code> as the result.</p>
<p>The result is given the same sign as the dividend (<code>self</code>), no matter the sign of
the divisor. This is consistent with the way <code>f64</code> behaves.</p>
<p>This implements the <code>%</code> operator between a reference to a <code>Double</code>s and a <code>Double</code>.</p>
<h1 id="examples-75" class="section-header"><a href="#examples-75">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_x</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected_x</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_x</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="op">-</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_y</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_y</span> <span class="op">=</span> (<span class="ident">y</span> <span class="op">-</span> <span class="ident">expected_y</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_y</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="ident">z</span> <span class="op">=</span> <span class="op">-</span><span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span> <span class="op">%</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_z</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_z</span> <span class="op">=</span> (<span class="ident">z</span> <span class="op">-</span> <span class="ident">expected_z</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_z</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-RemAssign%3C%26%27_%20Double%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.RemAssign.html" title="trait core::ops::arith::RemAssign">RemAssign</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-RemAssign%3C%26%27_%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/rem.rs.html#202-241" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.rem_assign-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.RemAssign.html#tymethod.rem_assign" class="fnname">rem_assign</a>(&amp;mut self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>)</code><a class="srclink" href="../src/qd/double/rem.rs.html#236-240" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the remainder of $x \div y$, where $x$ is <code>self</code> and $y$ is the argument,
assigning the result to <code>self</code>.</p>
<p>The result is given the same sign as the dividend (<code>self</code>), no matter the sign of
the divisor. This is consistent with the way <code>f64</code> behaves.</p>
<p>This implements the <code>%=</code> operator between a <code>Double</code> and a reference to a <code>Double</code>.</p>
<h1 id="examples-99" class="section-header"><a href="#examples-99">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="ident">x</span> <span class="op">%</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_x</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected_x</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_x</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">y</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="ident">y</span> <span class="op">%</span><span class="op">=</span> <span class="op">-</span><span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_y</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_y</span> <span class="op">=</span> (<span class="ident">y</span> <span class="op">-</span> <span class="ident">expected_y</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_y</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">z</span> <span class="op">=</span> <span class="op">-</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="ident">z</span> <span class="op">%</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_z</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_z</span> <span class="op">=</span> (<span class="ident">z</span> <span class="op">-</span> <span class="ident">expected_z</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_z</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-RemAssign%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.RemAssign.html" title="trait core::ops::arith::RemAssign">RemAssign</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-RemAssign%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/rem.rs.html#161-200" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.rem_assign" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.RemAssign.html#tymethod.rem_assign" class="fnname">rem_assign</a>(&amp;mut self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>)</code><a class="srclink" href="../src/qd/double/rem.rs.html#195-199" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes the remainder of $x \div y$, where $x$ is <code>self</code> and $y$ is the argument,
assigning the result to <code>self</code>.</p>
<p>The result is given the same sign as the dividend (<code>self</code>), no matter the sign of
the divisor. This is consistent with the way <code>f64</code> behaves.</p>
<p>This implements the <code>%=</code> operator between two <code>Double</code>s.</p>
<h1 id="examples-98" class="section-header"><a href="#examples-98">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="ident">x</span> <span class="op">%</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_x</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_x</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected_x</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_x</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">y</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="ident">y</span> <span class="op">%</span><span class="op">=</span> <span class="op">-</span><span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_y</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_y</span> <span class="op">=</span> (<span class="ident">y</span> <span class="op">-</span> <span class="ident">expected_y</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_y</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">z</span> <span class="op">=</span> <span class="op">-</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="ident">z</span> <span class="op">%</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="kw">let</span> <span class="ident">expected_z</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">delta_z</span> <span class="op">=</span> (<span class="ident">z</span> <span class="op">-</span> <span class="ident">expected_z</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">delta_z</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Sub%3C%26%27_%20Double%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Sub%3C%26%27_%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/sub.rs.html#43-64" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-9" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>-</code> operator.</p>
</div><h4 id="method.sub-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub" class="fnname">sub</a>(self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/sub.rs.html#61-63" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x - y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the binary <code>-</code> operator between two references to <code>Double</code>s.</p>
<h1 id="examples-77" class="section-header"><a href="#examples-77">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span> <span class="op">-</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Sub%3C%26%27_%20Double%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Sub%3C%26%27_%20Double%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/sub.rs.html#66-88" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-10" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>-</code> operator.</p>
</div><h4 id="method.sub-2" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub" class="fnname">sub</a>(self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/sub.rs.html#85-87" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x - y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the binary <code>-</code> operator between a <code>Double</code> and a reference to a
<code>Double</code>.</p>
<h1 id="examples-78" class="section-header"><a href="#examples-78">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span> <span class="op">-</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Sub%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Sub%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/sub.rs.html#12-41" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-8" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>-</code> operator.</p>
</div><h4 id="method.sub" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub" class="fnname">sub</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/sub.rs.html#29-40" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x - y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the binary <code>-</code> operator between two <code>Double</code>s.</p>
<h1 id="examples-76" class="section-header"><a href="#examples-76">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span> <span class="op">-</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Sub%3CDouble%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Sub%3CDouble%3E-1" class="anchor"></a><a class="srclink" href="../src/qd/double/sub.rs.html#90-112" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-11" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code></h4><div class='docblock'><p>The resulting type after applying the <code>-</code> operator.</p>
</div><h4 id="method.sub-3" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub" class="fnname">sub</a>(self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a class="srclink" href="../src/qd/double/sub.rs.html#109-111" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x - y$, where $x$ is <code>self</code> and $y$ is the argument, producing a new
<code>Double</code> as the result.</p>
<p>This implements the binary <code>-</code> operator between a reference to a <code>Double</code> and a
<code>Double</code>.</p>
<h1 id="examples-79" class="section-header"><a href="#examples-79">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">E</span> <span class="op">-</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-SubAssign%3C%26%27_%20Double%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;&amp;'_ <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-SubAssign%3C%26%27_%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/sub.rs.html#138-160" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.sub_assign-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fnname">sub_assign</a>(&amp;mut self, other: &amp;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>)</code><a class="srclink" href="../src/qd/double/sub.rs.html#155-159" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x - y$, where $x$ is <code>self</code> and $y$ is the argument, assigning the result
to <code>self</code>.</p>
<p>This implements the <code>-=</code> operator between a <code>Double</code> and a reference to a <code>Double</code>.</p>
<h1 id="examples-93" class="section-header"><a href="#examples-93">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="ident">x</span> <span class="op">-</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-SubAssign%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-SubAssign%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/sub.rs.html#114-136" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.sub_assign" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fnname">sub_assign</a>(&amp;mut self, other: <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>)</code><a class="srclink" href="../src/qd/double/sub.rs.html#131-135" title="goto source code">[src]</a></h4><div class="docblock"><p>Computes $x - y$, where $x$ is <code>self</code> and $y$ is the argument, assigning the result
to <code>self</code>.</p>
<p>This implements the <code>-=</code> operator between two <code>Double</code>s.</p>
<h1 id="examples-92" class="section-header"><a href="#examples-92">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Double</span>::<span class="ident">E</span>;
<span class="ident">x</span> <span class="op">-</span><span class="op">=</span> <span class="ident">Double</span>::<span class="ident">PI</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="string">&quot;-0.4233108251307480031023559119268&quot;</span>);

<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">x</span> <span class="op">-</span> <span class="ident">expected</span>).<span class="ident">abs</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">diff</span> <span class="op">&lt;</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">1e-30</span>));</pre></div>
</div></div><h3 id="impl-Sum%3C%26%27a%20Double%3E" class="impl"><code class="in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/accum/trait.Sum.html" title="trait core::iter::traits::accum::Sum">Sum</a>&lt;&amp;'a <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Sum%3C%26%27a%20Double%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/iter.rs.html#34-52" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.sum-1" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/accum/trait.Sum.html#tymethod.sum" class="fnname">sum</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = &amp;'a <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt;,&nbsp;</span></code><a class="srclink" href="../src/qd/double/iter.rs.html#46-51" title="goto source code">[src]</a></h4><div class="docblock"><p>Sums all of the referenced values in an iterator of <code>Double</code>s.</p>
<h1 id="examples-103" class="section-header"><a href="#examples-103">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">Sum</span>;

<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">15</span>);
<span class="kw">let</span> <span class="ident">actual</span>: <span class="ident">Double</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">5</span>)].<span class="ident">iter</span>().<span class="ident">sum</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">expected</span> <span class="op">=</span><span class="op">=</span> <span class="ident">actual</span>);</pre></div>
</div></div><h3 id="impl-Sum%3CDouble%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/accum/trait.Sum.html" title="trait core::iter::traits::accum::Sum">Sum</a>&lt;<a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt; for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Sum%3CDouble%3E" class="anchor"></a><a class="srclink" href="../src/qd/double/iter.rs.html#14-32" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.sum" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/accum/trait.Sum.html#tymethod.sum" class="fnname">sum</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a>&gt;,&nbsp;</span></code><a class="srclink" href="../src/qd/double/iter.rs.html#26-31" title="goto source code">[src]</a></h4><div class="docblock"><p>Sums all of the values in an iterator of <code>Double</code>s.</p>
<h1 id="examples-102" class="section-header"><a href="#examples-102">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">Sum</span>;

<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">dd</span><span class="macro">!</span>(<span class="number">15</span>);
<span class="kw">let</span> <span class="ident">actual</span>: <span class="ident">Double</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="macro">dd</span><span class="macro">!</span>(<span class="number">1</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">2</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">3</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">4</span>), <span class="macro">dd</span><span class="macro">!</span>(<span class="number">5</span>)].<span class="ident">into_iter</span>().<span class="ident">sum</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">expected</span> <span class="op">=</span><span class="op">=</span> <span class="ident">actual</span>);</pre></div>
</div></div><h3 id="impl-UpperExp" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperExp.html" title="trait core::fmt::UpperExp">UpperExp</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-UpperExp" class="anchor"></a><a class="srclink" href="../src/qd/double/display.rs.html#130-161" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt-3" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperExp.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../src/qd/double/display.rs.html#134-160" title="goto source code">[src]</a></h4><div class="docblock"><p>Formats a <code>Double</code> for display when the &quot;<code>E</code>&quot; formatting option is specified.</p>
<p>See <a href="#method.fmt-1"><code>Display::fmt</code></a> for more information.</p>
</div></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-RefUnwindSafe" class="anchor"></a><a class="srclink" href="../src/qd/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Send" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Send" class="anchor"></a><a class="srclink" href="../src/qd/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Sync" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Sync" class="anchor"></a><a class="srclink" href="../src/qd/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Unpin" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-Unpin" class="anchor"></a><a class="srclink" href="../src/qd/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../qd/struct.Double.html" title="struct qd::Double">Double</a></code><a href="#impl-UnwindSafe" class="anchor"></a><a class="srclink" href="../src/qd/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#108-112" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.type_id" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#109-111" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210-214" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211-213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217-221" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-220" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#552-556" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-15" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#553-555" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#541-548" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545-547" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-ToOwned" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href="#impl-ToOwned" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#80-92" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Owned" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id="method.to_owned" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#85-87" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id="method.clone_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89-91" title="goto source code">[src]</a></h4><div class="item-info hidden"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id="impl-ToString" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-ToString" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2194-2207" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.to_string" class="method hidden"><code>pub default fn <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2200-2206" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></p>
</div></div><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#589-598" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#595-597" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#575-584" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#581-583" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "qd";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>